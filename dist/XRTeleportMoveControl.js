var tn=Object.defineProperty;var en=(s,t,e)=>t in s?tn(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var U=(s,t,e)=>en(s,typeof t!="symbol"?t+"":t,e);import{j as Xt,e as z,g as yt,I as $e,J as Z,K as Mt,N as nn,i as I,B as k,U as sn,F as ue,X as Pe,z as rn,Y as on,n as Ye,f as cn,h as an,Z as Xe,M as St,l as Qt,b as $t,y as ln,_ as fn,p as un,$ as pn,a0 as hn,a1 as dn,C as yn,H as mn,Q as xn}from"./VRButton.js";import{m as wn,E as st}from"./ControllersManager.js";const ke=0,gn=1,An=2,Me=2,Jt=1.25,Be=1,vt=6*4+4+4,jt=65535,Tn=Math.pow(2,-24),te=Symbol("SKIP_GENERATION");function bn(s){return s.index?s.index.count:s.attributes.position.count}function mt(s){return bn(s)/3}function _n(s,t=ArrayBuffer){return s>65535?new Uint32Array(new t(4*s)):new Uint16Array(new t(2*s))}function Pn(s,t){if(!s.index){const e=s.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=_n(e,n);s.setIndex(new Xt(i,1));for(let o=0;o<e;o++)i[o]=o}}function je(s){const t=mt(s),e=s.drawRange,n=e.start/3,i=(e.start+e.count)/3,o=Math.max(0,n),r=Math.min(t,i)-o;return[{offset:Math.floor(o),count:Math.floor(r)}]}function Ze(s){if(!s.groups||!s.groups.length)return je(s);const t=[],e=new Set,n=s.drawRange,i=n.start/3,o=(n.start+n.count)/3;for(const c of s.groups){const a=c.start/3,u=(c.start+c.count)/3;e.add(Math.max(i,a)),e.add(Math.min(o,u))}const r=Array.from(e.values()).sort((c,a)=>c-a);for(let c=0;c<r.length-1;c++){const a=r[c],u=r[c+1];t.push({offset:Math.floor(a),count:Math.floor(u-a)})}return t}function Mn(s){if(s.groups.length===0)return!1;const t=mt(s),e=Ze(s).sort((o,r)=>o.offset-r.offset),n=e[e.length-1];n.count=Math.min(t-n.offset,n.count);let i=0;return e.forEach(({count:o})=>i+=o),t!==i}function ee(s,t,e,n,i){let o=1/0,r=1/0,c=1/0,a=-1/0,u=-1/0,f=-1/0,p=1/0,l=1/0,h=1/0,A=-1/0,T=-1/0,m=-1/0;for(let y=t*6,d=(t+e)*6;y<d;y+=6){const x=s[y+0],g=s[y+1],w=x-g,b=x+g;w<o&&(o=w),b>a&&(a=b),x<p&&(p=x),x>A&&(A=x);const _=s[y+2],M=s[y+3],P=_-M,S=_+M;P<r&&(r=P),S>u&&(u=S),_<l&&(l=_),_>T&&(T=_);const v=s[y+4],B=s[y+5],R=v-B,C=v+B;R<c&&(c=R),C>f&&(f=C),v<h&&(h=v),v>m&&(m=v)}n[0]=o,n[1]=r,n[2]=c,n[3]=a,n[4]=u,n[5]=f,i[0]=p,i[1]=l,i[2]=h,i[3]=A,i[4]=T,i[5]=m}function Bn(s,t=null,e=null,n=null){const i=s.attributes.position,o=s.index?s.index.array:null,r=mt(s),c=i.normalized;let a;t===null?(a=new Float32Array(r*6*4),e=0,n=r):(a=t,e=e||0,n=n||r);const u=i.array,f=i.offset||0;let p=3;i.isInterleavedBufferAttribute&&(p=i.data.stride);const l=["getX","getY","getZ"];for(let h=e;h<e+n;h++){const A=h*3,T=h*6;let m=A+0,y=A+1,d=A+2;o&&(m=o[m],y=o[y],d=o[d]),c||(m=m*p+f,y=y*p+f,d=d*p+f);for(let x=0;x<3;x++){let g,w,b;c?(g=i[l[x]](m),w=i[l[x]](y),b=i[l[x]](d)):(g=u[m+x],w=u[y+x],b=u[d+x]);let _=g;w<_&&(_=w),b<_&&(_=b);let M=g;w>M&&(M=w),b>M&&(M=b);const P=(M-_)/2,S=x*2;a[T+S+0]=_+P,a[T+S+1]=P+(Math.abs(_)+P)*Tn}}return a}function H(s,t,e){return e.min.x=t[s],e.min.y=t[s+1],e.min.z=t[s+2],e.max.x=t[s+3],e.max.y=t[s+4],e.max.z=t[s+5],e}function Se(s){let t=-1,e=-1/0;for(let n=0;n<3;n++){const i=s[n+3]-s[n];i>e&&(e=i,t=n)}return t}function ve(s,t){t.set(s)}function Re(s,t,e){let n,i;for(let o=0;o<3;o++){const r=o+3;n=s[o],i=t[o],e[o]=n<i?n:i,n=s[r],i=t[r],e[r]=n>i?n:i}}function zt(s,t,e){for(let n=0;n<3;n++){const i=t[s+2*n],o=t[s+2*n+1],r=i-o,c=i+o;r<e[n]&&(e[n]=r),c>e[n+3]&&(e[n+3]=c)}}function gt(s){const t=s[3]-s[0],e=s[4]-s[1],n=s[5]-s[2];return 2*(t*e+e*n+n*t)}const j=32,Sn=(s,t)=>s.candidate-t.candidate,J=new Array(j).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ct=new Float32Array(6);function vn(s,t,e,n,i,o){let r=-1,c=0;if(o===ke)r=Se(t),r!==-1&&(c=(t[r]+t[r+3])/2);else if(o===gn)r=Se(s),r!==-1&&(c=Rn(e,n,i,r));else if(o===An){const a=gt(s);let u=Jt*i;const f=n*6,p=(n+i)*6;for(let l=0;l<3;l++){const h=t[l],m=(t[l+3]-h)/j;if(i<j/4){const y=[...J];y.length=i;let d=0;for(let g=f;g<p;g+=6,d++){const w=y[d];w.candidate=e[g+2*l],w.count=0;const{bounds:b,leftCacheBounds:_,rightCacheBounds:M}=w;for(let P=0;P<3;P++)M[P]=1/0,M[P+3]=-1/0,_[P]=1/0,_[P+3]=-1/0,b[P]=1/0,b[P+3]=-1/0;zt(g,e,b)}y.sort(Sn);let x=i;for(let g=0;g<x;g++){const w=y[g];for(;g+1<x&&y[g+1].candidate===w.candidate;)y.splice(g+1,1),x--}for(let g=f;g<p;g+=6){const w=e[g+2*l];for(let b=0;b<x;b++){const _=y[b];w>=_.candidate?zt(g,e,_.rightCacheBounds):(zt(g,e,_.leftCacheBounds),_.count++)}}for(let g=0;g<x;g++){const w=y[g],b=w.count,_=i-w.count,M=w.leftCacheBounds,P=w.rightCacheBounds;let S=0;b!==0&&(S=gt(M)/a);let v=0;_!==0&&(v=gt(P)/a);const B=Be+Jt*(S*b+v*_);B<u&&(r=l,u=B,c=w.candidate)}}else{for(let x=0;x<j;x++){const g=J[x];g.count=0,g.candidate=h+m+x*m;const w=g.bounds;for(let b=0;b<3;b++)w[b]=1/0,w[b+3]=-1/0}for(let x=f;x<p;x+=6){let b=~~((e[x+2*l]-h)/m);b>=j&&(b=j-1);const _=J[b];_.count++,zt(x,e,_.bounds)}const y=J[j-1];ve(y.bounds,y.rightCacheBounds);for(let x=j-2;x>=0;x--){const g=J[x],w=J[x+1];Re(g.bounds,w.rightCacheBounds,g.rightCacheBounds)}let d=0;for(let x=0;x<j-1;x++){const g=J[x],w=g.count,b=g.bounds,M=J[x+1].rightCacheBounds;w!==0&&(d===0?ve(b,Ct):Re(b,Ct,Ct)),d+=w;let P=0,S=0;d!==0&&(P=gt(Ct)/a);const v=i-d;v!==0&&(S=gt(M)/a);const B=Be+Jt*(P*d+S*v);B<u&&(r=l,u=B,c=g.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:r,pos:c}}function Rn(s,t,e,n){let i=0;for(let o=t,r=t+e;o<r;o++)i+=s[o*6+n*2];return i/e}class ne{constructor(){this.boundingData=new Float32Array(6)}}function zn(s,t,e,n,i,o){let r=n,c=n+i-1;const a=o.pos,u=o.axis*2;for(;;){for(;r<=c&&e[r*6+u]<a;)r++;for(;r<=c&&e[c*6+u]>=a;)c--;if(r<c){for(let f=0;f<3;f++){let p=t[r*3+f];t[r*3+f]=t[c*3+f],t[c*3+f]=p}for(let f=0;f<6;f++){let p=e[r*6+f];e[r*6+f]=e[c*6+f],e[c*6+f]=p}r++,c--}else return r}}function Cn(s,t,e,n,i,o){let r=n,c=n+i-1;const a=o.pos,u=o.axis*2;for(;;){for(;r<=c&&e[r*6+u]<a;)r++;for(;r<=c&&e[c*6+u]>=a;)c--;if(r<c){let f=s[r];s[r]=s[c],s[c]=f;for(let p=0;p<6;p++){let l=e[r*6+p];e[r*6+p]=e[c*6+p],e[c*6+p]=l}r++,c--}else return r}}function V(s,t){return t[s+15]===65535}function O(s,t){return t[s+6]}function G(s,t){return t[s+14]}function q(s){return s+8}function W(s,t){return t[s+6]}function Ke(s,t){return t[s+7]}let Qe,Bt,Yt,Je;const En=Math.pow(2,32);function pe(s){return"count"in s?1:1+pe(s.left)+pe(s.right)}function Ln(s,t,e){return Qe=new Float32Array(e),Bt=new Uint32Array(e),Yt=new Uint16Array(e),Je=new Uint8Array(e),he(s,t)}function he(s,t){const e=s/4,n=s/2,i="count"in t,o=t.boundingData;for(let r=0;r<6;r++)Qe[e+r]=o[r];if(i)if(t.buffer){const r=t.buffer;Je.set(new Uint8Array(r),s);for(let c=s,a=s+r.byteLength;c<a;c+=vt){const u=c/2;V(u,Yt)||(Bt[c/4+6]+=e)}return s+r.byteLength}else{const r=t.offset,c=t.count;return Bt[e+6]=r,Yt[n+14]=c,Yt[n+15]=jt,s+vt}else{const r=t.left,c=t.right,a=t.splitAxis;let u;if(u=he(s+vt,r),u/4>En)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Bt[e+6]=u/4,u=he(u,c),Bt[e+7]=a,u}}function Un(s,t){const e=(s.index?s.index.count:s.attributes.position.count)/3,n=e>2**16,i=n?4:2,o=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),r=n?new Uint32Array(o):new Uint16Array(o);for(let c=0,a=r.length;c<a;c++)r[c]=c;return r}function Hn(s,t,e,n,i){const{maxDepth:o,verbose:r,maxLeafTris:c,strategy:a,onProgress:u,indirect:f}=i,p=s._indirectBuffer,l=s.geometry,h=l.index?l.index.array:null,A=f?Cn:zn,T=mt(l),m=new Float32Array(6);let y=!1;const d=new ne;return ee(t,e,n,d.boundingData,m),g(d,e,n,m),d;function x(w){u&&u(w/T)}function g(w,b,_,M=null,P=0){if(!y&&P>=o&&(y=!0,r&&(console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),console.warn(l))),_<=c||P>=o)return x(b+_),w.offset=b,w.count=_,w;const S=vn(w.boundingData,M,t,b,_,a);if(S.axis===-1)return x(b+_),w.offset=b,w.count=_,w;const v=A(p,h,t,b,_,S);if(v===b||v===b+_)x(b+_),w.offset=b,w.count=_;else{w.splitAxis=S.axis;const B=new ne,R=b,C=v-b;w.left=B,ee(t,R,C,B.boundingData,m),g(B,R,C,m,P+1);const E=new ne,F=v,Q=_-C;w.right=E,ee(t,F,Q,E.boundingData,m),g(E,F,Q,m,P+1)}return w}}function Fn(s,t){const e=s.geometry;t.indirect&&(s._indirectBuffer=Un(e,t.useSharedArrayBuffer),Mn(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),s._indirectBuffer||Pn(e,t);const n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Bn(e),o=t.indirect?je(e):Ze(e);s._roots=o.map(r=>{const c=Hn(s,i,r.offset,r.count,t),a=pe(c),u=new n(vt*a);return Ln(0,c,u),u})}class K{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,i=-1/0;for(let o=0,r=t.length;o<r;o++){const a=t[o][e];n=a<n?a:n,i=a>i?a:i}this.min=n,this.max=i}setFromPoints(t,e){let n=1/0,i=-1/0;for(let o=0,r=e.length;o<r;o++){const c=e[o],a=t.dot(c);n=a<n?a:n,i=a>i?a:i}this.min=n,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}K.prototype.setFromBox=function(){const s=new z;return function(e,n){const i=n.min,o=n.max;let r=1/0,c=-1/0;for(let a=0;a<=1;a++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){s.x=i.x*a+o.x*(1-a),s.y=i.y*u+o.y*(1-u),s.z=i.z*f+o.z*(1-f);const p=e.dot(s);r=Math.min(p,r),c=Math.max(p,c)}this.min=r,this.max=c}}();const Dn=function(){const s=new z,t=new z,e=new z;return function(i,o,r){const c=i.start,a=s,u=o.start,f=t;e.subVectors(c,u),s.subVectors(i.end,i.start),t.subVectors(o.end,o.start);const p=e.dot(f),l=f.dot(a),h=f.dot(f),A=e.dot(a),m=a.dot(a)*h-l*l;let y,d;m!==0?y=(p*l-A*h)/m:y=0,d=(p+y*l)/h,r.x=y,r.y=d}}(),Te=function(){const s=new yt,t=new z,e=new z;return function(i,o,r,c){Dn(i,o,s);let a=s.x,u=s.y;if(a>=0&&a<=1&&u>=0&&u<=1){i.at(a,r),o.at(u,c);return}else if(a>=0&&a<=1){u<0?o.at(0,c):o.at(1,c),i.closestPointToPoint(c,!0,r);return}else if(u>=0&&u<=1){a<0?i.at(0,r):i.at(1,r),o.closestPointToPoint(r,!0,c);return}else{let f;a<0?f=i.start:f=i.end;let p;u<0?p=o.start:p=o.end;const l=t,h=e;if(i.closestPointToPoint(p,!0,t),o.closestPointToPoint(f,!0,e),l.distanceToSquared(p)<=h.distanceToSquared(f)){r.copy(l),c.copy(p);return}else{r.copy(f),c.copy(h);return}}}}(),In=function(){const s=new z,t=new z,e=new $e,n=new Z;return function(o,r){const{radius:c,center:a}=o,{a:u,b:f,c:p}=r;if(n.start=u,n.end=f,n.closestPointToPoint(a,!0,s).distanceTo(a)<=c||(n.start=u,n.end=p,n.closestPointToPoint(a,!0,s).distanceTo(a)<=c)||(n.start=f,n.end=p,n.closestPointToPoint(a,!0,s).distanceTo(a)<=c))return!0;const T=r.getPlane(e);if(Math.abs(T.distanceToPoint(a))<=c){const y=T.projectPoint(a,t);if(r.containsPoint(y))return!0}return!1}}(),Nn=1e-15;function se(s){return Math.abs(s)<Nn}class X extends Mt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new z),this.satBounds=new Array(4).fill().map(()=>new K),this.points=[this.a,this.b,this.c],this.sphere=new nn,this.plane=new $e,this.needsUpdate=!0}intersectsSphere(t){return In(t,this)}update(){const t=this.a,e=this.b,n=this.c,i=this.points,o=this.satAxes,r=this.satBounds,c=o[0],a=r[0];this.getNormal(c),a.setFromPoints(c,i);const u=o[1],f=r[1];u.subVectors(t,e),f.setFromPoints(u,i);const p=o[2],l=r[2];p.subVectors(e,n),l.setFromPoints(p,i);const h=o[3],A=r[3];h.subVectors(n,t),A.setFromPoints(h,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,t),this.needsUpdate=!1}}X.prototype.closestPointToSegment=function(){const s=new z,t=new z,e=new Z;return function(i,o=null,r=null){const{start:c,end:a}=i,u=this.points;let f,p=1/0;for(let l=0;l<3;l++){const h=(l+1)%3;e.start.copy(u[l]),e.end.copy(u[h]),Te(e,i,s,t),f=s.distanceToSquared(t),f<p&&(p=f,o&&o.copy(s),r&&r.copy(t))}return this.closestPointToPoint(c,s),f=c.distanceToSquared(s),f<p&&(p=f,o&&o.copy(s),r&&r.copy(c)),this.closestPointToPoint(a,s),f=a.distanceToSquared(s),f<p&&(p=f,o&&o.copy(s),r&&r.copy(a)),Math.sqrt(p)}}();X.prototype.intersectsTriangle=function(){const s=new X,t=new Array(3),e=new Array(3),n=new K,i=new K,o=new z,r=new z,c=new z,a=new z,u=new z,f=new Z,p=new Z,l=new Z,h=new z;function A(T,m,y){const d=T.points;let x=0,g=-1;for(let w=0;w<3;w++){const{start:b,end:_}=f;b.copy(d[w]),_.copy(d[(w+1)%3]),f.delta(r);const M=se(m.distanceToPoint(b));if(se(m.normal.dot(r))&&M){y.copy(f),x=2;break}const P=m.intersectLine(f,h);if(!P&&M&&h.copy(b),(P||M)&&!se(h.distanceTo(_))){if(x<=1)(x===1?y.start:y.end).copy(h),M&&(g=x);else if(x>=2){(g===1?y.start:y.end).copy(h),x=2;break}if(x++,x===2&&g===-1)break}}return x}return function(m,y=null,d=!1){this.needsUpdate&&this.update(),m.isExtendedTriangle?m.needsUpdate&&m.update():(s.copy(m),s.update(),m=s);const x=this.plane,g=m.plane;if(Math.abs(x.normal.dot(g.normal))>1-1e-10){const w=this.satBounds,b=this.satAxes;e[0]=m.a,e[1]=m.b,e[2]=m.c;for(let P=0;P<4;P++){const S=w[P],v=b[P];if(n.setFromPoints(v,e),S.isSeparated(n))return!1}const _=m.satBounds,M=m.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let P=0;P<4;P++){const S=_[P],v=M[P];if(n.setFromPoints(v,t),S.isSeparated(n))return!1}for(let P=0;P<4;P++){const S=b[P];for(let v=0;v<4;v++){const B=M[v];if(o.crossVectors(S,B),n.setFromPoints(o,t),i.setFromPoints(o,e),n.isSeparated(i))return!1}}return y&&(d||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),y.start.set(0,0,0),y.end.set(0,0,0)),!0}else{const w=A(this,g,p);if(w===1&&m.containsPoint(p.end))return y&&(y.start.copy(p.end),y.end.copy(p.end)),!0;if(w!==2)return!1;const b=A(m,x,l);if(b===1&&this.containsPoint(l.end))return y&&(y.start.copy(l.end),y.end.copy(l.end)),!0;if(b!==2)return!1;if(p.delta(c),l.delta(a),c.dot(a)<0){let R=l.start;l.start=l.end,l.end=R}const _=p.start.dot(c),M=p.end.dot(c),P=l.start.dot(c),S=l.end.dot(c),v=M<P,B=_<S;return _!==S&&P!==M&&v===B?!1:(y&&(u.subVectors(p.start,l.start),u.dot(c)>0?y.start.copy(p.start):y.start.copy(l.start),u.subVectors(p.end,l.end),u.dot(c)<0?y.end.copy(p.end):y.end.copy(l.end)),!0)}}}();X.prototype.distanceToPoint=function(){const s=new z;return function(e){return this.closestPointToPoint(e,s),e.distanceTo(s)}}();X.prototype.distanceToTriangle=function(){const s=new z,t=new z,e=["a","b","c"],n=new Z,i=new Z;return function(r,c=null,a=null){const u=c||a?n:null;if(this.intersectsTriangle(r,u))return(c||a)&&(c&&u.getCenter(c),a&&u.getCenter(a)),0;let f=1/0;for(let p=0;p<3;p++){let l;const h=e[p],A=r[h];this.closestPointToPoint(A,s),l=A.distanceToSquared(s),l<f&&(f=l,c&&c.copy(s),a&&a.copy(A));const T=this[h];r.closestPointToPoint(T,s),l=T.distanceToSquared(s),l<f&&(f=l,c&&c.copy(T),a&&a.copy(s))}for(let p=0;p<3;p++){const l=e[p],h=e[(p+1)%3];n.set(this[l],this[h]);for(let A=0;A<3;A++){const T=e[A],m=e[(A+1)%3];i.set(r[T],r[m]),Te(n,i,s,t);const y=s.distanceToSquared(t);y<f&&(f=y,c&&c.copy(s),a&&a.copy(t))}}return Math.sqrt(f)}}();class N{constructor(t,e,n){this.isOrientedBox=!0,this.min=new z,this.max=new z,this.matrix=new I,this.invMatrix=new I,this.points=new Array(8).fill().map(()=>new z),this.satAxes=new Array(3).fill().map(()=>new z),this.satBounds=new Array(3).fill().map(()=>new K),this.alignedSatBounds=new Array(3).fill().map(()=>new K),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}N.prototype.update=function(){return function(){const t=this.matrix,e=this.min,n=this.max,i=this.points;for(let u=0;u<=1;u++)for(let f=0;f<=1;f++)for(let p=0;p<=1;p++){const l=1*u|2*f|4*p,h=i[l];h.x=u?n.x:e.x,h.y=f?n.y:e.y,h.z=p?n.z:e.z,h.applyMatrix4(t)}const o=this.satBounds,r=this.satAxes,c=i[0];for(let u=0;u<3;u++){const f=r[u],p=o[u],l=1<<u,h=i[l];f.subVectors(c,h),p.setFromPoints(f,i)}const a=this.alignedSatBounds;a[0].setFromPointsField(i,"x"),a[1].setFromPointsField(i,"y"),a[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();N.prototype.intersectsBox=function(){const s=new K;return function(e){this.needsUpdate&&this.update();const n=e.min,i=e.max,o=this.satBounds,r=this.satAxes,c=this.alignedSatBounds;if(s.min=n.x,s.max=i.x,c[0].isSeparated(s)||(s.min=n.y,s.max=i.y,c[1].isSeparated(s))||(s.min=n.z,s.max=i.z,c[2].isSeparated(s)))return!1;for(let a=0;a<3;a++){const u=r[a],f=o[a];if(s.setFromBox(u,e),f.isSeparated(s))return!1}return!0}}();N.prototype.intersectsTriangle=function(){const s=new X,t=new Array(3),e=new K,n=new K,i=new z;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(s.copy(r),s.update(),r=s);const c=this.satBounds,a=this.satAxes;t[0]=r.a,t[1]=r.b,t[2]=r.c;for(let l=0;l<3;l++){const h=c[l],A=a[l];if(e.setFromPoints(A,t),h.isSeparated(e))return!1}const u=r.satBounds,f=r.satAxes,p=this.points;for(let l=0;l<3;l++){const h=u[l],A=f[l];if(e.setFromPoints(A,p),h.isSeparated(e))return!1}for(let l=0;l<3;l++){const h=a[l];for(let A=0;A<4;A++){const T=f[A];if(i.crossVectors(h,T),e.setFromPoints(i,t),n.setFromPoints(i,p),e.isSeparated(n))return!1}}return!0}}();N.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();N.prototype.distanceToPoint=function(){const s=new z;return function(e){return this.closestPointToPoint(e,s),e.distanceTo(s)}}();N.prototype.distanceToBox=function(){const s=["x","y","z"],t=new Array(12).fill().map(()=>new Z),e=new Array(12).fill().map(()=>new Z),n=new z,i=new z;return function(r,c=0,a=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(a||u)&&(r.getCenter(i),this.closestPointToPoint(i,n),r.closestPointToPoint(n,i),a&&a.copy(n),u&&u.copy(i)),0;const f=c*c,p=r.min,l=r.max,h=this.points;let A=1/0;for(let m=0;m<8;m++){const y=h[m];i.copy(y).clamp(p,l);const d=y.distanceToSquared(i);if(d<A&&(A=d,a&&a.copy(y),u&&u.copy(i),d<f))return Math.sqrt(d)}let T=0;for(let m=0;m<3;m++)for(let y=0;y<=1;y++)for(let d=0;d<=1;d++){const x=(m+1)%3,g=(m+2)%3,w=y<<x|d<<g,b=1<<m|y<<x|d<<g,_=h[w],M=h[b];t[T].set(_,M);const S=s[m],v=s[x],B=s[g],R=e[T],C=R.start,E=R.end;C[S]=p[S],C[v]=y?p[v]:l[v],C[B]=d?p[B]:l[v],E[S]=l[S],E[v]=y?p[v]:l[v],E[B]=d?p[B]:l[v],T++}for(let m=0;m<=1;m++)for(let y=0;y<=1;y++)for(let d=0;d<=1;d++){i.x=m?l.x:p.x,i.y=y?l.y:p.y,i.z=d?l.z:p.z,this.closestPointToPoint(i,n);const x=i.distanceToSquared(n);if(x<A&&(A=x,a&&a.copy(n),u&&u.copy(i),x<f))return Math.sqrt(x)}for(let m=0;m<12;m++){const y=t[m];for(let d=0;d<12;d++){const x=e[d];Te(y,x,n,i);const g=n.distanceToSquared(i);if(g<A&&(A=g,a&&a.copy(n),u&&u.copy(i),g<f))return Math.sqrt(g)}}return Math.sqrt(A)}}();class be{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Vn extends be{constructor(){super(()=>new X)}}const $=new Vn;class On{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const L=new On;let et,dt;const it=[],Et=new be(()=>new k);function Gn(s,t,e,n,i,o){et=Et.getPrimitive(),dt=Et.getPrimitive(),it.push(et,dt),L.setBuffer(s._roots[t]);const r=de(0,s.geometry,e,n,i,o);L.clearBuffer(),Et.releasePrimitive(et),Et.releasePrimitive(dt),it.pop(),it.pop();const c=it.length;return c>0&&(dt=it[c-1],et=it[c-2]),r}function de(s,t,e,n,i=null,o=0,r=0){const{float32Array:c,uint16Array:a,uint32Array:u}=L;let f=s*2;if(V(f,a)){const l=O(s,u),h=G(f,a);return H(s,c,et),n(l,h,!1,r,o+s,et)}else{let S=function(B){const{uint16Array:R,uint32Array:C}=L;let E=B*2;for(;!V(E,R);)B=q(B),E=B*2;return O(B,C)},v=function(B){const{uint16Array:R,uint32Array:C}=L;let E=B*2;for(;!V(E,R);)B=W(B,C),E=B*2;return O(B,C)+G(E,R)};const l=q(s),h=W(s,u);let A=l,T=h,m,y,d,x;if(i&&(d=et,x=dt,H(A,c,d),H(T,c,x),m=i(d),y=i(x),y<m)){A=h,T=l;const B=m;m=y,y=B,d=x}d||(d=et,H(A,c,d));const g=V(A*2,a),w=e(d,g,m,r+1,o+A);let b;if(w===Me){const B=S(A),C=v(A)-B;b=n(B,C,!0,r+1,o+A,d)}else b=w&&de(A,t,e,n,i,o,r+1);if(b)return!0;x=dt,H(T,c,x);const _=V(T*2,a),M=e(x,_,y,r+1,o+T);let P;if(M===Me){const B=S(T),C=v(T)-B;P=n(B,C,!0,r+1,o+T,x)}else P=M&&de(T,t,e,n,i,o,r+1);return!!P}}const At=new z,ie=new z;function qn(s,t,e={},n=0,i=1/0){const o=n*n,r=i*i;let c=1/0,a=null;if(s.shapecast({boundsTraverseOrder:f=>(At.copy(t).clamp(f.min,f.max),At.distanceToSquared(t)),intersectsBounds:(f,p,l)=>l<c&&l<r,intersectsTriangle:(f,p)=>{f.closestPointToPoint(t,At);const l=t.distanceToSquared(At);return l<c&&(ie.copy(At),c=l,a=p),l<o}}),c===1/0)return null;const u=Math.sqrt(c);return e.point?e.point.copy(ie):e.point=ie.clone(),e.distance=u,e.faceIndex=a,e}const rt=new z,ot=new z,ct=new z,Lt=new yt,Ut=new yt,Ht=new yt,ze=new z,Ce=new z,Ee=new z,Ft=new z;function Wn(s,t,e,n,i,o,r,c){let a;if(o===sn?a=s.intersectTriangle(n,e,t,!0,i):a=s.intersectTriangle(t,e,n,o!==ue,i),a===null)return null;const u=s.origin.distanceTo(i);return u<r||u>c?null:{distance:u,point:i.clone()}}function $n(s,t,e,n,i,o,r,c,a,u,f){rt.fromBufferAttribute(t,o),ot.fromBufferAttribute(t,r),ct.fromBufferAttribute(t,c);const p=Wn(s,rt,ot,ct,Ft,a,u,f);if(p){n&&(Lt.fromBufferAttribute(n,o),Ut.fromBufferAttribute(n,r),Ht.fromBufferAttribute(n,c),p.uv=Mt.getInterpolation(Ft,rt,ot,ct,Lt,Ut,Ht,new yt)),i&&(Lt.fromBufferAttribute(i,o),Ut.fromBufferAttribute(i,r),Ht.fromBufferAttribute(i,c),p.uv1=Mt.getInterpolation(Ft,rt,ot,ct,Lt,Ut,Ht,new yt)),e&&(ze.fromBufferAttribute(e,o),Ce.fromBufferAttribute(e,r),Ee.fromBufferAttribute(e,c),p.normal=Mt.getInterpolation(Ft,rt,ot,ct,ze,Ce,Ee,new z),p.normal.dot(s.direction)>0&&p.normal.multiplyScalar(-1));const l={a:o,b:r,c,normal:new z,materialIndex:0};Mt.getNormal(rt,ot,ct,l.normal),p.face=l,p.faceIndex=o}return p}function Zt(s,t,e,n,i,o,r){const c=n*3;let a=c+0,u=c+1,f=c+2;const p=s.index;s.index&&(a=p.getX(a),u=p.getX(u),f=p.getX(f));const{position:l,normal:h,uv:A,uv1:T}=s.attributes,m=$n(e,l,h,A,T,a,u,f,t,o,r);return m?(m.faceIndex=n,i&&i.push(m),m):null}function D(s,t,e,n){const i=s.a,o=s.b,r=s.c;let c=t,a=t+1,u=t+2;e&&(c=e.getX(c),a=e.getX(a),u=e.getX(u)),i.x=n.getX(c),i.y=n.getY(c),i.z=n.getZ(c),o.x=n.getX(a),o.y=n.getY(a),o.z=n.getZ(a),r.x=n.getX(u),r.y=n.getY(u),r.z=n.getZ(u)}function Yn(s,t,e,n,i,o,r,c){const{geometry:a,_indirectBuffer:u}=s;for(let f=n,p=n+i;f<p;f++)Zt(a,t,e,f,o,r,c)}function Xn(s,t,e,n,i,o,r){const{geometry:c,_indirectBuffer:a}=s;let u=1/0,f=null;for(let p=n,l=n+i;p<l;p++){let h;h=Zt(c,t,e,p,null,o,r),h&&h.distance<u&&(f=h,u=h.distance)}return f}function kn(s,t,e,n,i,o,r){const{geometry:c}=e,{index:a}=c,u=c.attributes.position;for(let f=s,p=t+s;f<p;f++){let l;if(l=f,D(r,l*3,a,u),r.needsUpdate=!0,n(r,l,i,o))return!0}return!1}function jn(s,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=s.geometry,n=e.index?e.index.array:null,i=e.attributes.position;let o,r,c,a,u=0;const f=s._roots;for(let l=0,h=f.length;l<h;l++)o=f[l],r=new Uint32Array(o),c=new Uint16Array(o),a=new Float32Array(o),p(0,u),u+=o.byteLength;function p(l,h,A=!1){const T=l*2;if(c[T+15]===jt){const y=r[l+6],d=c[T+14];let x=1/0,g=1/0,w=1/0,b=-1/0,_=-1/0,M=-1/0;for(let P=3*y,S=3*(y+d);P<S;P++){let v=n[P];const B=i.getX(v),R=i.getY(v),C=i.getZ(v);B<x&&(x=B),B>b&&(b=B),R<g&&(g=R),R>_&&(_=R),C<w&&(w=C),C>M&&(M=C)}return a[l+0]!==x||a[l+1]!==g||a[l+2]!==w||a[l+3]!==b||a[l+4]!==_||a[l+5]!==M?(a[l+0]=x,a[l+1]=g,a[l+2]=w,a[l+3]=b,a[l+4]=_,a[l+5]=M,!0):!1}else{const y=l+8,d=r[l+6],x=y+h,g=d+h;let w=A,b=!1,_=!1;t?w||(b=t.has(x),_=t.has(g),w=!b&&!_):(b=!0,_=!0);const M=w||b,P=w||_;let S=!1;M&&(S=p(y,h,w));let v=!1;P&&(v=p(d,h,w));const B=S||v;if(B)for(let R=0;R<3;R++){const C=y+R,E=d+R,F=a[C],Q=a[C+3],xt=a[E],wt=a[E+3];a[l+R]=F<xt?F:xt,a[l+R+3]=Q>wt?Q:wt}return B}}}function nt(s,t,e,n,i){let o,r,c,a,u,f;const p=1/e.direction.x,l=1/e.direction.y,h=1/e.direction.z,A=e.origin.x,T=e.origin.y,m=e.origin.z;let y=t[s],d=t[s+3],x=t[s+1],g=t[s+3+1],w=t[s+2],b=t[s+3+2];return p>=0?(o=(y-A)*p,r=(d-A)*p):(o=(d-A)*p,r=(y-A)*p),l>=0?(c=(x-T)*l,a=(g-T)*l):(c=(g-T)*l,a=(x-T)*l),o>a||c>r||((c>o||isNaN(o))&&(o=c),(a<r||isNaN(r))&&(r=a),h>=0?(u=(w-m)*h,f=(b-m)*h):(u=(b-m)*h,f=(w-m)*h),o>f||u>r)?!1:((u>o||o!==o)&&(o=u),(f<r||r!==r)&&(r=f),o<=i&&r>=n)}function Zn(s,t,e,n,i,o,r,c){const{geometry:a,_indirectBuffer:u}=s;for(let f=n,p=n+i;f<p;f++){let l=u?u[f]:f;Zt(a,t,e,l,o,r,c)}}function Kn(s,t,e,n,i,o,r){const{geometry:c,_indirectBuffer:a}=s;let u=1/0,f=null;for(let p=n,l=n+i;p<l;p++){let h;h=Zt(c,t,e,a?a[p]:p,null,o,r),h&&h.distance<u&&(f=h,u=h.distance)}return f}function Qn(s,t,e,n,i,o,r){const{geometry:c}=e,{index:a}=c,u=c.attributes.position;for(let f=s,p=t+s;f<p;f++){let l;if(l=e.resolveTriangleIndex(f),D(r,l*3,a,u),r.needsUpdate=!0,n(r,l,i,o))return!0}return!1}function Jn(s,t,e,n,i,o,r){L.setBuffer(s._roots[t]),ye(0,s,e,n,i,o,r),L.clearBuffer()}function ye(s,t,e,n,i,o,r){const{float32Array:c,uint16Array:a,uint32Array:u}=L,f=s*2;if(V(f,a)){const l=O(s,u),h=G(f,a);Yn(t,e,n,l,h,i,o,r)}else{const l=q(s);nt(l,c,n,o,r)&&ye(l,t,e,n,i,o,r);const h=W(s,u);nt(h,c,n,o,r)&&ye(h,t,e,n,i,o,r)}}const ts=["x","y","z"];function es(s,t,e,n,i,o){L.setBuffer(s._roots[t]);const r=me(0,s,e,n,i,o);return L.clearBuffer(),r}function me(s,t,e,n,i,o){const{float32Array:r,uint16Array:c,uint32Array:a}=L;let u=s*2;if(V(u,c)){const p=O(s,a),l=G(u,c);return Xn(t,e,n,p,l,i,o)}else{const p=Ke(s,a),l=ts[p],A=n.direction[l]>=0;let T,m;A?(T=q(s),m=W(s,a)):(T=W(s,a),m=q(s));const d=nt(T,r,n,i,o)?me(T,t,e,n,i,o):null;if(d){const w=d.point[l];if(A?w<=r[m+p]:w>=r[m+p+3])return d}const g=nt(m,r,n,i,o)?me(m,t,e,n,i,o):null;return d&&g?d.distance<=g.distance?d:g:d||g||null}}const Dt=new k,at=new X,lt=new X,Tt=new I,Le=new N,It=new N;function ns(s,t,e,n){L.setBuffer(s._roots[t]);const i=xe(0,s,e,n);return L.clearBuffer(),i}function xe(s,t,e,n,i=null){const{float32Array:o,uint16Array:r,uint32Array:c}=L;let a=s*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Le.set(e.boundingBox.min,e.boundingBox.max,n),i=Le),V(a,r)){const f=t.geometry,p=f.index,l=f.attributes.position,h=e.index,A=e.attributes.position,T=O(s,c),m=G(a,r);if(Tt.copy(n).invert(),e.boundsTree)return H(s,o,It),It.matrix.copy(Tt),It.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:d=>It.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(n),d.b.applyMatrix4(n),d.c.applyMatrix4(n),d.needsUpdate=!0;for(let x=T*3,g=(m+T)*3;x<g;x+=3)if(D(lt,x,p,l),lt.needsUpdate=!0,d.intersectsTriangle(lt))return!0;return!1}});for(let y=T*3,d=(m+T)*3;y<d;y+=3){D(at,y,p,l),at.a.applyMatrix4(Tt),at.b.applyMatrix4(Tt),at.c.applyMatrix4(Tt),at.needsUpdate=!0;for(let x=0,g=h.count;x<g;x+=3)if(D(lt,x,h,A),lt.needsUpdate=!0,at.intersectsTriangle(lt))return!0}}else{const f=s+8,p=c[s+6];return H(f,o,Dt),!!(i.intersectsBox(Dt)&&xe(f,t,e,n,i)||(H(p,o,Dt),i.intersectsBox(Dt)&&xe(p,t,e,n,i)))}}const Nt=new I,re=new N,bt=new N,ss=new z,is=new z,rs=new z,os=new z;function cs(s,t,e,n={},i={},o=0,r=1/0){t.boundingBox||t.computeBoundingBox(),re.set(t.boundingBox.min,t.boundingBox.max,e),re.needsUpdate=!0;const c=s.geometry,a=c.attributes.position,u=c.index,f=t.attributes.position,p=t.index,l=$.getPrimitive(),h=$.getPrimitive();let A=ss,T=is,m=null,y=null;i&&(m=rs,y=os);let d=1/0,x=null,g=null;return Nt.copy(e).invert(),bt.matrix.copy(Nt),s.shapecast({boundsTraverseOrder:w=>re.distanceToBox(w),intersectsBounds:(w,b,_)=>_<d&&_<r?(b&&(bt.min.copy(w.min),bt.max.copy(w.max),bt.needsUpdate=!0),!0):!1,intersectsRange:(w,b)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:M=>bt.distanceToBox(M),intersectsBounds:(M,P,S)=>S<d&&S<r,intersectsRange:(M,P)=>{for(let S=M,v=M+P;S<v;S++){D(h,3*S,p,f),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let B=w,R=w+b;B<R;B++){D(l,3*B,u,a),l.needsUpdate=!0;const C=l.distanceToTriangle(h,A,m);if(C<d&&(T.copy(A),y&&y.copy(m),d=C,x=B,g=S),C<o)return!0}}}});{const _=mt(t);for(let M=0,P=_;M<P;M++){D(h,3*M,p,f),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let S=w,v=w+b;S<v;S++){D(l,3*S,u,a),l.needsUpdate=!0;const B=l.distanceToTriangle(h,A,m);if(B<d&&(T.copy(A),y&&y.copy(m),d=B,x=S,g=M),B<o)return!0}}}}}),$.releasePrimitive(l),$.releasePrimitive(h),d===1/0?null:(n.point?n.point.copy(T):n.point=T.clone(),n.distance=d,n.faceIndex=x,i&&(i.point?i.point.copy(y):i.point=y.clone(),i.point.applyMatrix4(Nt),T.applyMatrix4(Nt),i.distance=T.sub(i.point).length(),i.faceIndex=g),n)}function as(s,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=s.geometry,n=e.index?e.index.array:null,i=e.attributes.position;let o,r,c,a,u=0;const f=s._roots;for(let l=0,h=f.length;l<h;l++)o=f[l],r=new Uint32Array(o),c=new Uint16Array(o),a=new Float32Array(o),p(0,u),u+=o.byteLength;function p(l,h,A=!1){const T=l*2;if(c[T+15]===jt){const y=r[l+6],d=c[T+14];let x=1/0,g=1/0,w=1/0,b=-1/0,_=-1/0,M=-1/0;for(let P=y,S=y+d;P<S;P++){const v=3*s.resolveTriangleIndex(P);for(let B=0;B<3;B++){let R=v+B;R=n?n[R]:R;const C=i.getX(R),E=i.getY(R),F=i.getZ(R);C<x&&(x=C),C>b&&(b=C),E<g&&(g=E),E>_&&(_=E),F<w&&(w=F),F>M&&(M=F)}}return a[l+0]!==x||a[l+1]!==g||a[l+2]!==w||a[l+3]!==b||a[l+4]!==_||a[l+5]!==M?(a[l+0]=x,a[l+1]=g,a[l+2]=w,a[l+3]=b,a[l+4]=_,a[l+5]=M,!0):!1}else{const y=l+8,d=r[l+6],x=y+h,g=d+h;let w=A,b=!1,_=!1;t?w||(b=t.has(x),_=t.has(g),w=!b&&!_):(b=!0,_=!0);const M=w||b,P=w||_;let S=!1;M&&(S=p(y,h,w));let v=!1;P&&(v=p(d,h,w));const B=S||v;if(B)for(let R=0;R<3;R++){const C=y+R,E=d+R,F=a[C],Q=a[C+3],xt=a[E],wt=a[E+3];a[l+R]=F<xt?F:xt,a[l+R+3]=Q>wt?Q:wt}return B}}}function ls(s,t,e,n,i,o,r){L.setBuffer(s._roots[t]),we(0,s,e,n,i,o,r),L.clearBuffer()}function we(s,t,e,n,i,o,r){const{float32Array:c,uint16Array:a,uint32Array:u}=L,f=s*2;if(V(f,a)){const l=O(s,u),h=G(f,a);Zn(t,e,n,l,h,i,o,r)}else{const l=q(s);nt(l,c,n,o,r)&&we(l,t,e,n,i,o,r);const h=W(s,u);nt(h,c,n,o,r)&&we(h,t,e,n,i,o,r)}}const fs=["x","y","z"];function us(s,t,e,n,i,o){L.setBuffer(s._roots[t]);const r=ge(0,s,e,n,i,o);return L.clearBuffer(),r}function ge(s,t,e,n,i,o){const{float32Array:r,uint16Array:c,uint32Array:a}=L;let u=s*2;if(V(u,c)){const p=O(s,a),l=G(u,c);return Kn(t,e,n,p,l,i,o)}else{const p=Ke(s,a),l=fs[p],A=n.direction[l]>=0;let T,m;A?(T=q(s),m=W(s,a)):(T=W(s,a),m=q(s));const d=nt(T,r,n,i,o)?ge(T,t,e,n,i,o):null;if(d){const w=d.point[l];if(A?w<=r[m+p]:w>=r[m+p+3])return d}const g=nt(m,r,n,i,o)?ge(m,t,e,n,i,o):null;return d&&g?d.distance<=g.distance?d:g:d||g||null}}const Vt=new k,ft=new X,ut=new X,_t=new I,Ue=new N,Ot=new N;function ps(s,t,e,n){L.setBuffer(s._roots[t]);const i=Ae(0,s,e,n);return L.clearBuffer(),i}function Ae(s,t,e,n,i=null){const{float32Array:o,uint16Array:r,uint32Array:c}=L;let a=s*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Ue.set(e.boundingBox.min,e.boundingBox.max,n),i=Ue),V(a,r)){const f=t.geometry,p=f.index,l=f.attributes.position,h=e.index,A=e.attributes.position,T=O(s,c),m=G(a,r);if(_t.copy(n).invert(),e.boundsTree)return H(s,o,Ot),Ot.matrix.copy(_t),Ot.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:d=>Ot.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(n),d.b.applyMatrix4(n),d.c.applyMatrix4(n),d.needsUpdate=!0;for(let x=T,g=m+T;x<g;x++)if(D(ut,3*t.resolveTriangleIndex(x),p,l),ut.needsUpdate=!0,d.intersectsTriangle(ut))return!0;return!1}});for(let y=T,d=m+T;y<d;y++){const x=t.resolveTriangleIndex(y);D(ft,3*x,p,l),ft.a.applyMatrix4(_t),ft.b.applyMatrix4(_t),ft.c.applyMatrix4(_t),ft.needsUpdate=!0;for(let g=0,w=h.count;g<w;g+=3)if(D(ut,g,h,A),ut.needsUpdate=!0,ft.intersectsTriangle(ut))return!0}}else{const f=s+8,p=c[s+6];return H(f,o,Vt),!!(i.intersectsBox(Vt)&&Ae(f,t,e,n,i)||(H(p,o,Vt),i.intersectsBox(Vt)&&Ae(p,t,e,n,i)))}}const Gt=new I,oe=new N,Pt=new N,hs=new z,ds=new z,ys=new z,ms=new z;function xs(s,t,e,n={},i={},o=0,r=1/0){t.boundingBox||t.computeBoundingBox(),oe.set(t.boundingBox.min,t.boundingBox.max,e),oe.needsUpdate=!0;const c=s.geometry,a=c.attributes.position,u=c.index,f=t.attributes.position,p=t.index,l=$.getPrimitive(),h=$.getPrimitive();let A=hs,T=ds,m=null,y=null;i&&(m=ys,y=ms);let d=1/0,x=null,g=null;return Gt.copy(e).invert(),Pt.matrix.copy(Gt),s.shapecast({boundsTraverseOrder:w=>oe.distanceToBox(w),intersectsBounds:(w,b,_)=>_<d&&_<r?(b&&(Pt.min.copy(w.min),Pt.max.copy(w.max),Pt.needsUpdate=!0),!0):!1,intersectsRange:(w,b)=>{if(t.boundsTree){const _=t.boundsTree;return _.shapecast({boundsTraverseOrder:M=>Pt.distanceToBox(M),intersectsBounds:(M,P,S)=>S<d&&S<r,intersectsRange:(M,P)=>{for(let S=M,v=M+P;S<v;S++){const B=_.resolveTriangleIndex(S);D(h,3*B,p,f),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let R=w,C=w+b;R<C;R++){const E=s.resolveTriangleIndex(R);D(l,3*E,u,a),l.needsUpdate=!0;const F=l.distanceToTriangle(h,A,m);if(F<d&&(T.copy(A),y&&y.copy(m),d=F,x=R,g=S),F<o)return!0}}}})}else{const _=mt(t);for(let M=0,P=_;M<P;M++){D(h,3*M,p,f),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let S=w,v=w+b;S<v;S++){const B=s.resolveTriangleIndex(S);D(l,3*B,u,a),l.needsUpdate=!0;const R=l.distanceToTriangle(h,A,m);if(R<d&&(T.copy(A),y&&y.copy(m),d=R,x=S,g=M),R<o)return!0}}}}}),$.releasePrimitive(l),$.releasePrimitive(h),d===1/0?null:(n.point?n.point.copy(T):n.point=T.clone(),n.distance=d,n.faceIndex=x,i&&(i.point?i.point.copy(y):i.point=y.clone(),i.point.applyMatrix4(Gt),T.applyMatrix4(Gt),i.distance=T.sub(i.point).length(),i.faceIndex=g),n)}function ws(){return typeof SharedArrayBuffer<"u"}const Rt=new L.constructor,kt=new L.constructor,tt=new be(()=>new k),pt=new k,ht=new k,ce=new k,ae=new k;let le=!1;function gs(s,t,e,n){if(le)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");le=!0;const i=s._roots,o=t._roots;let r,c=0,a=0;const u=new I().copy(e).invert();for(let f=0,p=i.length;f<p;f++){Rt.setBuffer(i[f]),a=0;const l=tt.getPrimitive();H(0,Rt.float32Array,l),l.applyMatrix4(u);for(let h=0,A=o.length;h<A&&(kt.setBuffer(o[f]),r=Y(0,0,e,u,n,c,a,0,0,l),kt.clearBuffer(),a+=o[h].length,!r);h++);if(tt.releasePrimitive(l),Rt.clearBuffer(),c+=i[f].length,r)break}return le=!1,r}function Y(s,t,e,n,i,o=0,r=0,c=0,a=0,u=null,f=!1){let p,l;f?(p=kt,l=Rt):(p=Rt,l=kt);const h=p.float32Array,A=p.uint32Array,T=p.uint16Array,m=l.float32Array,y=l.uint32Array,d=l.uint16Array,x=s*2,g=t*2,w=V(x,T),b=V(g,d);let _=!1;if(b&&w)f?_=i(O(t,y),G(t*2,d),O(s,A),G(s*2,T),a,r+t,c,o+s):_=i(O(s,A),G(s*2,T),O(t,y),G(t*2,d),c,o+s,a,r+t);else if(b){const M=tt.getPrimitive();H(t,m,M),M.applyMatrix4(e);const P=q(s),S=W(s,A);H(P,h,pt),H(S,h,ht);const v=M.intersectsBox(pt),B=M.intersectsBox(ht);_=v&&Y(t,P,n,e,i,r,o,a,c+1,M,!f)||B&&Y(t,S,n,e,i,r,o,a,c+1,M,!f),tt.releasePrimitive(M)}else{const M=q(t),P=W(t,y);H(M,m,ce),H(P,m,ae);const S=u.intersectsBox(ce),v=u.intersectsBox(ae);if(S&&v)_=Y(s,M,e,n,i,o,r,c,a+1,u,f)||Y(s,P,e,n,i,o,r,c,a+1,u,f);else if(S)if(w)_=Y(s,M,e,n,i,o,r,c,a+1,u,f);else{const B=tt.getPrimitive();B.copy(ce).applyMatrix4(e);const R=q(s),C=W(s,A);H(R,h,pt),H(C,h,ht);const E=B.intersectsBox(pt),F=B.intersectsBox(ht);_=E&&Y(M,R,n,e,i,r,o,a,c+1,B,!f)||F&&Y(M,C,n,e,i,r,o,a,c+1,B,!f),tt.releasePrimitive(B)}else if(v)if(w)_=Y(s,P,e,n,i,o,r,c,a+1,u,f);else{const B=tt.getPrimitive();B.copy(ae).applyMatrix4(e);const R=q(s),C=W(s,A);H(R,h,pt),H(C,h,ht);const E=B.intersectsBox(pt),F=B.intersectsBox(ht);_=E&&Y(P,R,n,e,i,r,o,a,c+1,B,!f)||F&&Y(P,C,n,e,i,r,o,a,c+1,B,!f),tt.releasePrimitive(B)}}return _}const qt=new N,He=new k,As={strategy:ke,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class Kt{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,i=t._roots,o=t._indirectBuffer,r=n.getIndex();let c;return e.cloneBuffers?c={roots:i.map(a=>a.slice()),index:r?r.array.slice():null,indirectBuffer:o?o.slice():null}:c={roots:i,index:r?r.array:null,indirectBuffer:o},c}static deserialize(t,e,n={}){n={setIndex:!0,indirect:!!t.indirectBuffer,...n};const{index:i,roots:o,indirectBuffer:r}=t,c=new Kt(e,{...n,[te]:!0});if(c._roots=o,c._indirectBuffer=r||null,n.setIndex){const a=e.getIndex();if(a===null){const u=new Xt(t.index,1,!1);e.setIndex(u)}else a.array!==i&&(a.array.set(i),a.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...As,[te]:!1},e),e.useSharedArrayBuffer&&!ws())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[te]||(Fn(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new k))),this.resolveTriangleIndex=e.indirect?n=>this._indirectBuffer[n]:n=>n}refit(t=null){return(this.indirect?as:jn)(this,t)}traverse(t,e=0){const n=this._roots[e],i=new Uint32Array(n),o=new Uint16Array(n);r(0);function r(c,a=0){const u=c*2,f=o[u+15]===jt;if(f){const p=i[c+6],l=o[u+14];t(a,f,new Float32Array(n,c*4,6),p,l)}else{const p=c+vt/4,l=i[c+6],h=i[c+7];t(a,f,new Float32Array(n,c*4,6),h)||(r(p,a+1),r(l,a+1))}}}raycast(t,e=Pe,n=0,i=1/0){const o=this._roots,r=this.geometry,c=[],a=e.isMaterial,u=Array.isArray(e),f=r.groups,p=a?e.side:e,l=this.indirect?ls:Jn;for(let h=0,A=o.length;h<A;h++){const T=u?e[f[h].materialIndex].side:p,m=c.length;if(l(this,h,T,t,c,n,i),u){const y=f[h].materialIndex;for(let d=m,x=c.length;d<x;d++)c[d].face.materialIndex=y}}return c}raycastFirst(t,e=Pe,n=0,i=1/0){const o=this._roots,r=this.geometry,c=e.isMaterial,a=Array.isArray(e);let u=null;const f=r.groups,p=c?e.side:e,l=this.indirect?us:es;for(let h=0,A=o.length;h<A;h++){const T=a?e[f[h].materialIndex].side:p,m=l(this,h,T,t,n,i);m!=null&&(u==null||m.distance<u.distance)&&(u=m,a&&(m.face.materialIndex=f[h].materialIndex))}return u}intersectsGeometry(t,e){let n=!1;const i=this._roots,o=this.indirect?ps:ns;for(let r=0,c=i.length;r<c&&(n=o(this,r,t,e),!n);r++);return n}shapecast(t){const e=$.getPrimitive(),n=this.indirect?Qn:kn;let{boundsTraverseOrder:i,intersectsBounds:o,intersectsRange:r,intersectsTriangle:c}=t;if(r&&c){const p=r;r=(l,h,A,T,m)=>p(l,h,A,T,m)?!0:n(l,h,this,c,A,T,e)}else r||(c?r=(p,l,h,A)=>n(p,l,this,c,h,A,e):r=(p,l,h)=>h);let a=!1,u=0;const f=this._roots;for(let p=0,l=f.length;p<l;p++){const h=f[p];if(a=Gn(this,p,o,r,i,u),a)break;u+=h.byteLength}return $.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:i,intersectsTriangles:o}=n;const r=$.getPrimitive(),c=this.geometry.index,a=this.geometry.attributes.position,u=this.indirect?A=>{const T=this.resolveTriangleIndex(A);D(r,T*3,c,a)}:A=>{D(r,A*3,c,a)},f=$.getPrimitive(),p=t.geometry.index,l=t.geometry.attributes.position,h=t.indirect?A=>{const T=t.resolveTriangleIndex(A);D(f,T*3,p,l)}:A=>{D(f,A*3,p,l)};if(o){const A=(T,m,y,d,x,g,w,b)=>{for(let _=y,M=y+d;_<M;_++){h(_),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let P=T,S=T+m;P<S;P++)if(u(P),r.needsUpdate=!0,o(r,f,P,_,x,g,w,b))return!0}return!1};if(i){const T=i;i=function(m,y,d,x,g,w,b,_){return T(m,y,d,x,g,w,b,_)?!0:A(m,y,d,x,g,w,b,_)}}else i=A}return gs(this,t,e,i)}intersectsBox(t,e){return qt.set(t.min,t.max,e),qt.needsUpdate=!0,this.shapecast({intersectsBounds:n=>qt.intersectsBox(n),intersectsTriangle:n=>qt.intersectsTriangle(n)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},i={},o=0,r=1/0){return(this.indirect?xs:cs)(this,t,e,n,i,o,r)}closestPointToPoint(t,e={},n=0,i=1/0){return qn(this,t,e,n,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(n=>{H(0,new Float32Array(n),He),t.union(He)}),t}}const Fe=new k;class Ts extends cn{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,n=10,i=0){super(),this.material=e,this.geometry=new an,this.name="MeshBVHRootHelper",this.depth=n,this.displayParents=!1,this.bvh=t,this.displayEdges=!0,this._group=i}raycast(){}update(){const t=this.geometry,e=this.bvh,n=this._group;if(t.dispose(),this.visible=!1,e){const i=this.depth-1,o=this.displayParents;let r=0;e.traverse((l,h)=>{if(l>=i||h)return r++,!0;o&&r++},n);let c=0;const a=new Float32Array(8*3*r);e.traverse((l,h,A)=>{const T=l>=i||h;if(T||o){H(0,A,Fe);const{min:m,max:y}=Fe;for(let d=-1;d<=1;d+=2){const x=d<0?m.x:y.x;for(let g=-1;g<=1;g+=2){const w=g<0?m.y:y.y;for(let b=-1;b<=1;b+=2){const _=b<0?m.z:y.z;a[c+0]=x,a[c+1]=w,a[c+2]=_,c+=3}}}return T}},n);let u,f;this.displayEdges?f=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):f=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),a.length>65535?u=new Uint32Array(f.length*r):u=new Uint16Array(f.length*r);const p=f.length;for(let l=0;l<r;l++){const h=l*8,A=l*p;for(let T=0;T<p;T++)u[A+T]=h+f[T]}t.setIndex(new Xt(u,1,!1)),t.setAttribute("position",new Xt(a,3,!1)),this.visible=!0}}}class _e extends rn{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t=null,e=null,n=10){t instanceof Kt&&(n=e||10,e=t,t=null),typeof e=="number"&&(n=e,e=null),super(),this.name="MeshBVHHelper",this.depth=n,this.mesh=t,this.bvh=e,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const i=new on({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),o=new Ye({color:65416,transparent:!0,opacity:.3,depthWrite:!1});o.color=i.color,this.edgeMaterial=i,this.meshMaterial=o,this.update()}update(){const t=this.bvh||this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;){const n=this._roots.pop();n.geometry.dispose(),this.remove(n)}for(let n=0;n<e;n++){const{depth:i,edgeMaterial:o,meshMaterial:r,displayParents:c,displayEdges:a}=this;if(n>=this._roots.length){const f=new Ts(t,o,i,n);this.add(f),this._roots.push(f)}const u=this._roots[n];u.bvh=t,u.depth=i,u.displayParents=c,u.displayEdges=a,u.material=a?o:r,u.update()}}updateMatrixWorld(...t){const e=this.mesh,n=this.parent;e!==null&&(e.updateWorldMatrix(!0,!1),n?this.matrix.copy(n.matrixWorld).invert().multiply(e.matrixWorld):this.matrix.copy(e.matrixWorld),this.matrix.decompose(this.position,this.quaternion,this.scale)),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh,this.bvh=t.bvh,this.opacity=t.opacity,this.color.copy(t.color)}clone(){return new _e(this.mesh,this.bvh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].geometry.dispose()}}function De(s,t,e){return s===null?null:(s.point.applyMatrix4(t.matrixWorld),s.distance=s.point.distanceTo(e.ray.origin),s.object=t,s)}const Wt=new Xe,Ie=new z,Ne=new I,bs=St.prototype.raycast,Ve=new z;function _s(s,t){if(this.geometry.boundsTree){if(this.material===void 0)return;Ne.copy(this.matrixWorld).invert(),Wt.copy(s.ray).applyMatrix4(Ne),Bs(this.matrixWorld,Ve),Ie.copy(Wt.direction).multiply(Ve);const e=Ie.length(),n=s.near/e,i=s.far/e,o=this.geometry.boundsTree;if(s.firstHitOnly===!0){const r=De(o.raycastFirst(Wt,this.material,n,i),this,s);r&&t.push(r)}else{const r=o.raycast(Wt,this.material,n,i);for(let c=0,a=r.length;c<a;c++){const u=De(r[c],this,s);u&&t.push(u)}}}else bs.call(this,s,t)}function Ps(s){return this.boundsTree=new Kt(this,s),this.boundsTree}function Ms(){this.boundsTree=null}function Bs(s,t){const e=s.elements,n=t.set(e[0],e[1],e[2]).length(),i=t.set(e[4],e[5],e[6]).length(),o=t.set(e[8],e[9],e[10]).length();return t.set(n,i,o)}const fe=[{x:16711680,y:65280,z:255},{x:65535,y:16711935,z:16776960}];class Oe extends St{constructor(t=1,e=.1,n=0){const i=[],o=new Qt(t,e,e);o.translate(t/2,0,0),i.push(o);const r=new Qt(e,t,e);r.translate(0,t/2,0),i.push(r);const c=new Qt(e,e,t);c.translate(0,0,t/2),i.push(c);const a=wn(i),u=[new $t({color:fe[n].x}),new $t({color:fe[n].y}),new $t({color:fe[n].z})];a.groups=[{start:0,count:o.index.count,materialIndex:0},{start:o.index.count,count:r.index.count,materialIndex:1},{start:o.index.count+r.index.count,count:c.index.count,materialIndex:2}],super(a,u)}}const Ss=.5,vs=.3,Ge=.02,Rs=1500,qe=Math.PI/12,We=15,zs=10,Cs=.75,Es={showHelpers:!0,enableContinousMotion:!0,restrictVerticalMovement:!1,enabledHands:"right"};class Fs{constructor(t,e,n,i={}){U(this,"options");U(this,"controllersManager");U(this,"scene");U(this,"xrManager");U(this,"raycaster");U(this,"testSurface");U(this,"teleportGizmo");U(this,"gizmoArrow");U(this,"vrIsPresenting");U(this,"xrRigidTransform");U(this,"baseReferenceSpace");U(this,"referenceSpaceHelper");U(this,"worldSpaceHelper");U(this,"vrCamera");U(this,"worldOffset",new z(0,0,0));U(this,"worldYRotation",0*Math.PI/2);U(this,"userHeight");U(this,"userHeightHasBeenMeasured",!1);U(this,"testRay");U(this,"arrowHelper");U(this,"enabledHands",[]);U(this,"_teleportGestureIsActive",!1);if(this.options=Object.assign(Es,i),this.xrManager=t,this.controllersManager=e,this.scene=n,this.raycaster=new ln,this.raycaster.firstHitOnly=!0,this.testRay=new Xe(new z(0,15,0),new z(0,-1,0)),this.options.showHelpers){this.referenceSpaceHelper=new Oe(1.5,.02,0);let o=this._createSpriteLabel("Reference Space",1);o.position.set(0,1,0),o.frustumCulled=!1,this.referenceSpaceHelper.add(o),this.scene.add(this.referenceSpaceHelper),this.worldSpaceHelper=new Oe(.75,.04,1),o=this._createSpriteLabel("World Space",1),o.frustumCulled=!1,o.position.set(0,.5,0),this.worldSpaceHelper.add(o),this.scene.add(this.worldSpaceHelper)}this.options.enabledHands=="both"?this.enabledHands=["left","right"]:this.enabledHands=[this.options.enabledHands],this._setupListeners(),this._buildGizmo()}_setupListeners(){this.xrManager.addEventListener("sessionstart",t=>{this.userHeightHasBeenMeasured=!1,this.vrIsPresenting=!0,this.baseReferenceSpace=this.xrManager.getReferenceSpace(),this.vrCamera=this.xrManager.getCamera(),this._applyCurrentTransform()}),this.xrManager.addEventListener("sessionend",t=>{this.vrIsPresenting=!1,this.baseReferenceSpace=null}),this.controllersManager.addEventListener(st.ON_RAY_STARTED,t=>{var n;if(!this._teleportSurfaces||!this.enabledHands.includes(t.handedness))return;this.raycaster.ray=t.ray;let e=this.raycaster.intersectObject(this._teleportSurfaces);return e&&((n=e[0])!=null&&n.point)?(this._teleportGestureIsActive=!0,!1):!0},-999),this.controllersManager.addEventListener(st.ON_RAY_UPDATED,t=>{var n,i;if(!this._teleportSurfaces||!this.enabledHands.includes(t.handedness)||!this._teleportGestureIsActive)return;this.raycaster.ray=t.ray;let e=this.raycaster.intersectObject(this._teleportSurfaces);if(e&&((n=e[0])!=null&&n.point)&&((i=e[0])!=null&&i.face)&&this._isHorizontalSurface(e[0].face.normal)){let o=e[0].point;return this._updateTeleportGizmo(new z(o.x,o.y,o.z),t.stickPosition,t.ray),!1}return!0},-999),this.controllersManager.addEventListener(st.ON_RAY_ENDED,t=>{var i,o;if(!this._teleportSurfaces||!this._teleportGestureIsActive||!this.enabledHands.includes(t.handedness))return;this.raycaster.ray=t.ray;const e=this.raycaster.intersectObject(this._teleportSurfaces);let n;if(e&&((i=e[0])!=null&&i.point)&&((o=e[0])!=null&&o.face)&&this._isHorizontalSurface(e[0].face.normal)){let r=e[0].point;this._teleport(new z(r.x,r.y,r.z),t.stickPosition,t.ray),n=!1}return n=!0,this._teleportGestureIsActive=!1,this.teleportGizmo.visible=!1,n},-999),this._updateArrow=t=>{this.arrowHelper&&this.scene.remove(this.arrowHelper),this.arrowHelper=new fn(t.direction,t.origin,20,16750848),this.scene.add(this.arrowHelper)},this.controllersManager.addEventListener(st.ON_ROTATE_LEFT,t=>{this._teleportGestureIsActive||!this.enabledHands.includes(t.handedness)||this._rotate(-We)},-999),this.controllersManager.addEventListener(st.ON_ROTATE_RIGHT,t=>{this._teleportGestureIsActive||!this.enabledHands.includes(t.handedness)||this._rotate(We)},-999),this.options.enableContinousMotion&&this.controllersManager.addEventListener(st.ON_AXIS_Y_NOT_ZERO,t=>{this._teleportGestureIsActive||!this.enabledHands.includes(t.handedness)||this._moveInDirection(t.ray,t.stickPosition.y,t.deltaTime)},-999)}_isHorizontalSurface(t){return new z().copy(t).transformDirection(this._teleportSurfaces.matrixWorld).y>Cs}_getTeleportGizmoAngle(t,e){let n=e.direction.clone();n.y=0,n.normalize();let i=Math.atan2(n.z,n.x),o=Math.atan2(t.y,-t.x);return o=Math.round(o/qe)*qe,Math.PI/2+o-i}_createSpriteLabel(t="",e=1){const n=document.createElement("canvas"),i=n.getContext("2d");n.width=256,n.height=256,i.font="24px Arial	",i.fillStyle="white",i.textAlign="center",i.textBaseline="middle",i.fillText(t,n.width/2,n.height/2);const o=new un(n),r=new pn({map:o,depthWrite:!1}),c=new hn(r);return c.scale.set(e,e,e),c}_rotate(t){if(!this.vrIsPresenting||!this.baseReferenceSpace)return;let e=t*Math.PI/180;this.worldYRotation+=e;let n=this.worldOffset.clone(),i=this.vrCamera.position.clone(),o=new I().fromArray(this.xrRigidTransform.matrix);i.applyMatrix4(o);let r=new I().makeTranslation(i.x,0,i.z),c=new I().makeRotationY(e),a=new I().makeTranslation(-i.x,0,-i.z),u=new I;u.multiply(r),u.multiply(c),u.multiply(a),n.applyMatrix4(u),this.worldOffset.copy(n),this._applyCurrentTransform(),this.teleportGizmo.visible=!1}_buildGizmo(){new $t({color:65535,emissive:5592405,shininess:32});const t=new dn({uniforms:{cameraPosition:{value:new z(1,1,1)}},vertexShader:`
					precision mediump float;

	
					
					varying vec3 vNormal;
					varying vec3 vPosition;

					void main() {
						vNormal = normalize(normalMatrix*vec4(normal,1.0).xyz);
						vPosition = (modelViewMatrix*vec4(position,1.0)).xyz;
						gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
					}
				`,fragmentShader:`
					
					varying vec3 vNormal;
					varying vec3 vPosition;

					void main() {
													
						float xrayOpacity = 0.8 - 0.6*abs(dot( vNormal, vec3(0.0,0.0,1.0) ));
						gl_FragColor = vec4(0.0, 0.8, 1.0, xrayOpacity );
						//gl_FragColor = vec4(vNormal, 1.0 );
					}
				`,transparent:!0,side:ue,depthWrite:!1}),e=new yn(.2,.2,.05,3);e.rotateY(Math.PI/2),e.translate(.65,-.025,0),this.gizmoArrow=new St(e,t),this.gizmoArrow.visible=!1;const n=new mn(vs,Ge,16,100);n.rotateX(Math.PI/2),this.teleportGizmo=new St(n,t),this.teleportGizmo.add(this.gizmoArrow),this.scene.add(this.teleportGizmo),this.teleportGizmo.visible=!1}_updateTeleportGizmo(t,e,n){this.teleportGizmo.visible=!0,this.teleportGizmo.position.set(t.x,t.y+Ge/2,t.z),e.length()>Ss?(this.gizmoArrow.visible=!0,this.gizmoArrow.rotation.y=this._getTeleportGizmoAngle(e,n),this.gizmoArrow.userData.lastUpdate=Date.now()):this.gizmoArrow.visible=!1}_measureUserHeight(){if(this.userHeightHasBeenMeasured||!this.vrIsPresenting)return;let t=this.vrCamera.position.clone();if(t.length()===0)return;let e=new I().fromArray(this.xrRigidTransform.matrix);t.applyMatrix4(e),this.userHeight=t.y,this.userHeightHasBeenMeasured=!0}_teleport(t,e,n){if(!this.vrIsPresenting||!this.baseReferenceSpace)return;const i=this.gizmoArrow.userData.lastUpdate?Date.now()-this.gizmoArrow.userData.lastUpdate:1/0;if(e&&n&&i<Rs){let u=this.vrCamera.getWorldDirection(new z(0,0,-1));u.y=0,u.normalize();let f=Math.atan2(u.z,u.x),l=-(this.gizmoArrow.rotation.y+f);this.worldYRotation+=l}this.gizmoArrow.visible=!1;let o=t.clone().negate(),r=new I().makeRotationY(this.worldYRotation);o.applyMatrix4(r);let c=this.vrCamera.position.clone(),a=new I().fromArray(this.xrRigidTransform.matrix);c.applyMatrix4(a),o.x+=c.x,o.z+=c.z,this.worldOffset.set(o.x,o.y,o.z),this._applyCurrentTransform(),this.teleportGizmo.visible=!1}_moveInDirection(t,e,n){let i=t.direction.clone();i.normalize(),this.options.restrictVerticalMovement&&(i.y=0,i.normalize()),i.multiplyScalar(e*zs*n);let o=new I().makeRotationY(this.worldYRotation);i.applyMatrix4(o),this.worldOffset.add(i)}_applyCurrentTransform(){if(!this.baseReferenceSpace)return;let t=this.worldOffset.clone(),e=new xn;e.setFromAxisAngle(new z(0,1,0),this.worldYRotation),this.xrRigidTransform=new XRRigidTransform(new z(t.x,t.y,t.z),e);const n=this.baseReferenceSpace.getOffsetReferenceSpace(this.xrRigidTransform);this.xrManager.setReferenceSpace(n);let i=new I().fromArray(this.xrRigidTransform.matrix);i.invert();let o=new z;o.applyMatrix4(i),this.options.showHelpers&&(this.referenceSpaceHelper.position.copy(o),this.referenceSpaceHelper.rotation.setFromRotationMatrix(i))}getXRRigidTransform(){return new I().fromArray(this.xrRigidTransform.matrix)}update(t){this.vrIsPresenting&&this._applyCurrentTransform()}setTeleportSurfaces(t){if(t.computeBoundsTree=Ps.bind(t),t.disposeBoundsTree=Ms.bind(t),t.computeBoundsTree(),this._teleportSurfaces=new St(t,new Ye({side:ue})),this._teleportSurfaces.raycast=_s.bind(this._teleportSurfaces),this._teleportSurfaces.updateMatrixWorld(),this.options.showHelpers){let e=new _e(this._teleportSurfaces,16711680);e.displayEdges=!0,this.scene.add(e)}}_testRayCaster(){this.testRay.origin.set(0,20,0),this.testRay.direction.set(0,-1,0),this.raycaster.ray=this.testRay,this._updateArrow(this.testRay);const t=this.raycaster.intersectObject(this._teleportSurfaces);console.log("intersection",t)}}export{Fs as X};
//# sourceMappingURL=XRTeleportMoveControl.js.map
