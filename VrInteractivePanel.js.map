{"version":3,"file":"VrInteractivePanel.js","sources":["../src/xr/InteractiveVRObject.js","../src/xr/VrInteractivePanel.js"],"sourcesContent":["import * as THREE from 'three';\r\nimport { ControllersManager, EventTypes as CMEventTypes } from './ControllersManager.js';\r\n\r\nexport const defaultOptions = {\r\n\tdebugLevel: 1,\r\n};\r\n\r\nexport class InteractiveVRObject {\r\n\t_raycaster; // raycaster used for hit testing\r\n\t_hitTestMesh; // mesh used for hit testing\r\n\t_lastRayStartedOnHand; // hand that started the ray\r\n\t_options; // options\r\n\t_leftHitMarker; // left hit marker\r\n\t_rightHitMarker; // right hit marker\r\n\t_targetObject; // target object\r\n\r\n\tconstructor(targetObject, worldContainer, controllersManager, options) {\r\n\t\tthis.options = { ...defaultOptions, ...options };\r\n\t\tif (worldContainer === undefined || controllersManager === undefined || targetObject === undefined) {\r\n\t\t\tthrow Error('InteractiveVRObject: Missing parameters');\r\n\t\t}\r\n\r\n\t\t// if targetObject does not implement the required methods, throw an error\r\n\t\tif (typeof targetObject.onRayStarted !== 'function' || typeof targetObject.onRayEnded !== 'function') {\r\n\t\t\tthrow Error('InteractiveVRObject: targetObject does not implement the required methods');\r\n\t\t}\r\n\r\n\t\tif (targetObject?.getIntersectionMesh() != undefined) {\r\n\t\t\tthis._hitTestMesh = targetObject.getIntersectionMesh();\r\n\t\t} else {\r\n\t\t\tthrow Error('InteractiveVRObject: targetObject does not implement the getIntersectionMesh method');\r\n\t\t}\r\n\r\n\t\tthis._targetObject = targetObject;\r\n\t\tthis._controllersManager = controllersManager;\r\n\t\tthis._worldContainer = worldContainer;\r\n\t\tthis._controllersManager = controllersManager;\r\n\t\tthis._raycaster = new THREE.Raycaster();\r\n\r\n\t\t// create hit markers\r\n\t\tif (this.options.debugLevel > 0) {\r\n\t\t\tconst markerGeo = new THREE.SphereGeometry(0.01, 16, 8);\r\n\t\t\tthis._leftHitMarker = new THREE.Mesh(markerGeo, new THREE.MeshBasicMaterial({ color: 0xff0000 }));\r\n\t\t\tthis._rightHitMarker = new THREE.Mesh(markerGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00 }));\r\n\t\t\t//this._leftHitMarker.visible = false;\r\n\t\t\t//this._rightHitMarker.visible = false;\r\n\r\n\t\t\tthis._worldContainer.add(this._leftHitMarker);\r\n\t\t\tthis._worldContainer.add(this._rightHitMarker);\r\n\t\t}\r\n\r\n\t\tthis._setupEventListeners();\r\n\t}\r\n\r\n\t_setupEventListeners() {\r\n\t\tconst events = [\r\n\t\t\t{ type: CMEventTypes.ON_RAY_STARTED, handler: '_onRayStarted' },\r\n\t\t\t{ type: CMEventTypes.ON_RAY_UPDATED, handler: '_onRayUpdated' },\r\n\t\t\t{ type: CMEventTypes.ON_RAY_ENDED, handler: '_onRayEnded' },\r\n\t\t];\r\n\r\n\t\tevents.forEach((event) => {\r\n\t\t\tthis._controllersManager.addEventListener(\r\n\t\t\t\tevent.type,\r\n\t\t\t\tthis[event.handler].bind(this)\r\n\t\t\t\t//this._targetObject[event.handler].bind(this._targetObject)\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n\r\n\t// Ray event handlers\r\n\t_onRayStarted(e) {\r\n\t\tif (!this._targetObject.shouldTestRayEvents()) return true;\r\n\r\n\t\tlet allowEventPropagation = true;\r\n\t\tlet intersection = this._getRayIntersection(e.ray);\r\n\t\tif (intersection && !this._lastRayStartedOnHand) {\r\n\t\t\t// store the hand that started the ray or the \"mouse down\"\r\n\t\t\tthis._lastRayStartedOnHand = e.handedness;\r\n\t\t\tallowEventPropagation = false;\r\n\t\t\tif (this._targetObject.onRayStarted) this._targetObject.onRayStarted(intersection);\r\n\t\t}\r\n\t\treturn allowEventPropagation;\r\n\t}\r\n\r\n\t_onRayUpdated(e) {\r\n\t\tif (!this._targetObject.shouldTestRayEvents()) return true;\r\n\r\n\t\tlet allowEventPropagation = true;\r\n\t\tlet marker = e.handedness == 'left' ? this._leftHitMarker : this._rightHitMarker;\r\n\t\tlet intersection = this._getRayIntersection(e.ray);\r\n\t\tif (intersection) {\r\n\t\t\t// if the ray hand is the same that started the ray or generated\r\n\t\t\t// the mouse down, update the mouse position\r\n\t\t\tif (this._lastRayStartedOnHand == e.handedness) {\r\n\t\t\t\tallowEventPropagation = false;\r\n\t\t\t\tif (this._targetObject.onRayUpdated) this._targetObject.onRayUpdated(intersection);\r\n\t\t\t}\r\n\t\t\t// update marker position and visibility, corresponding to the hand\r\n\t\t\tlet d = e.ray.origin.distanceTo(intersection.point);\r\n\t\t\tlet s = 1 + d * 0.5;\r\n\r\n\t\t\tmarker.position.copy(intersection.point);\r\n\t\t\tmarker.scale.set(s, s, s);\r\n\t\t\tmarker.visible = true;\r\n\t\t} else {\r\n\t\t\tmarker.visible = false;\r\n\t\t}\r\n\t\treturn allowEventPropagation;\r\n\t}\r\n\r\n\t_onRayEnded(e) {\r\n\t\tif (!this._targetObject.shouldTestRayEvents()) return true;\r\n\t\tlet allowEventPropagation = true;\r\n\t\tlet marker = e.handedness == 'left' ? this._leftHitMarker : this._rightHitMarker;\r\n\t\tlet intersection = this._getRayIntersection(e.ray);\r\n\t\t// Only trigger mouse up if the hand that started the ray is the same that ended it\r\n\t\tif (this._lastRayStartedOnHand == e.handedness) {\r\n\t\t\t// only trigger mouse up if the ray is over the menu\r\n\r\n\t\t\tif (this._targetObject.onRayEnded) this._targetObject.onRayEnded(intersection);\r\n\r\n\t\t\t// clear the last ray started hand\r\n\t\t\tthis._lastRayStartedOnHand = null;\r\n\t\t\tallowEventPropagation = false;\r\n\t\t}\r\n\r\n\t\tmarker.visible = false;\r\n\r\n\t\treturn allowEventPropagation;\r\n\t}\r\n\r\n\t_getRayIntersection(ray) {\r\n\t\tif (this._hitTestMesh && ray) {\r\n\t\t\tthis._raycaster.ray = ray;\r\n\t\t\tconst intersection = this._raycaster.intersectObject(this._hitTestMesh, false)?.[0];\r\n\t\t\tif (intersection) {\r\n\t\t\t\treturn intersection;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n}\r\n","import * as THREE from 'three';\r\nimport { ControllersManager, EventTypes as CMEventTypes } from './ControllersManager.js';\r\nimport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\r\nimport { InteractiveVRObject } from './InteractiveVRObject.js';\r\n\r\nexport const defaultOptions = {\r\n\tmode: 'panel', // \"swatch\", \"panel\",\r\n\tdebugLevel: 1,\r\n\r\n\tsize: 1, // meters\r\n};\r\n\r\n/*\r\nVrInteractivePanel class is designed to create an interactive VR panel within a Three.js scene. \r\n\r\nIt extends the functionality of a basic 3D object by integrating VR-specific\r\ninteractions, such as handling ray events from VR controllers. \r\n\r\nThe class sets up a 3D panel with front and back faces, manages its visibility, \r\nand updates its aspect ratio based on the dynamic content dimensions.\r\n\r\nIt also includes methods for handling ray events (onRayStarted, onRayUpdated, onRayEnded) required by\r\nthe InteractiveVRObject class, which facilitates interaction with VR controllers. \r\n\r\nThe class is intended to be extended by subclasses that implement specific UI functionality, \r\nas indicated by the abstract methods initCanvas, _onPointerEvent, and ui.\r\n\r\n*/\r\n\r\nexport class VrInteractivePanel {\r\n\t_container;\r\n\t_mesh;\r\n\t_map;\r\n\r\n\t_mapYScale;\r\n\t_mapYOffset;\r\n\r\n\t_controllersManager;\r\n\t_worldContainer;\r\n\r\n\t_frontMaterial;\r\n\t_backMaterial;\r\n\r\n\tconstructor(worldContainer, controllersManager, options) {\r\n\t\tthis.options = { ...defaultOptions, ...options };\r\n\r\n\t\tif (worldContainer === undefined || controllersManager === undefined) {\r\n\t\t\tthrow Error('VrMenu: Missing parameters');\r\n\t\t}\r\n\t\tthis._controllersManager = controllersManager;\r\n\t\tthis._worldContainer = worldContainer;\r\n\r\n\t\tthis._container = new THREE.Group();\r\n\r\n\t\tthis._frontMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\r\n\t\tthis._backMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });\r\n\r\n\t\tthis._mesh = new THREE.Mesh(this._buildGeometry(), [this._backMaterial, this._frontMaterial]);\r\n\t\tthis._container.add(this._mesh);\r\n\r\n\t\t// axes helper\r\n\t\t//this._container.add(new THREE.AxesHelper(1));\r\n\r\n\t\tthis._interactiveVRObject = new InteractiveVRObject(this, worldContainer, controllersManager);\r\n\t}\r\n\r\n\t_buildGeometry() {\r\n\t\t// create geometry for the menu with front and back faces\r\n\t\tconst frontface = new THREE.PlaneGeometry(this.options.size, this.options.size);\r\n\t\tconst backface = new THREE.PlaneGeometry(this.options.size, this.options.size);\r\n\t\tbackface.rotateY(Math.PI);\r\n\t\tlet geo = new THREE.BufferGeometry();\r\n\t\tgeo = BufferGeometryUtils.mergeGeometries([backface, frontface]);\r\n\t\tlet c1 = frontface.index.count;\r\n\t\tlet c2 = backface.index.count;\r\n\t\tgeo.addGroup(0, c1, 0);\r\n\t\tgeo.addGroup(c1, c2, 1);\r\n\t\treturn geo;\r\n\t}\r\n\r\n\tsetVisible(visible) {\r\n\t\tthis._container.visible = visible;\r\n\t}\r\n\r\n\ttoggleVisibility() {\r\n\t\tthis._container.visible = !this._container.visible;\r\n\t\tthis.setVisible(this._container.visible);\r\n\t}\r\n\r\n\t// canvasHeightPx is the height of the canvas in pixels\r\n\t// canvasWidthPx is the width of the canvas in pixels\r\n\t// contentHeightPx is the height of the content in pixels within the canvas\r\n\r\n\t_updateAspectRatio(canvasWidthPx, canvasHeightPx, contentHeightPx) {\r\n\t\t0;\r\n\t\tconst aspect = canvasWidthPx / contentHeightPx;\r\n\r\n\t\t// map 0 .. contentHeightPx to 0 .. 1, to cover the whole mesh with the UI pixels only\r\n\t\tconst yScale = contentHeightPx / canvasHeightPx; // map scaling factor\r\n\t\t// We center the map in the canvas, vertically\r\n\t\tconst yOffset = 1 - yScale;\r\n\r\n\t\t// extend the area covered by the content, to cover the whole canvas\r\n\t\tthis._map.offset.set(0, yOffset);\r\n\t\tthis._map.repeat.set(1, yScale);\r\n\r\n\t\tthis._mesh.scale.y = 1 / aspect;\r\n\t\t//this._mesh.position.y = this._mesh.scale.y / 2;\r\n\t\t/*\r\n\t\tif (this.options.debugLevel > 0) {\r\n\t\t\tconsole.log('_updateUiAspectRatio()');\r\n\t\t\tconsole.log('canvas w,h:', canvasWidthPx, canvasHeightPx);\r\n\t\t\tconsole.log('contentHeightPx:', contentHeightPx);\r\n\t\t\tconsole.log('yOffset:', yOffset);\r\n\t\t\tconsole.log('yScale:', yScale);\r\n\t\t\tconsole.log('aspect:', aspect);\r\n\t\t}*/\r\n\r\n\t\tthis._mapYOffset = yOffset;\r\n\t\tthis._mapYScale = yScale;\r\n\t}\r\n\r\n\t// Ray event handlers required by InteractiveVRObject\r\n\r\n\tonRayStarted(intersection) {\r\n\t\tthis._onPointerEvent(this._createPointerEvent('pointerdown', intersection));\r\n\t}\r\n\r\n\tonRayUpdated(intersection) {\r\n\t\tthis._onPointerEvent(this._createPointerEvent('pointermove', intersection));\r\n\t}\r\n\r\n\tonRayEnded(intersection) {\r\n\t\tif (intersection) {\r\n\t\t\tthis._onPointerEvent(this._createPointerEvent('pointerup', intersection));\r\n\t\t} else {\r\n\t\t\tthis._onPointerEvent(this._createPointerEvent('pointerupoutside'));\r\n\t\t}\r\n\t}\r\n\r\n\t_createPointerEvent(type, intersection) {\r\n\t\tlet event = { type: type };\r\n\t\tif (intersection && intersection.uv) {\r\n\t\t\tlet coords = intersection.uv.clone();\r\n\t\t\tcoords.y = coords.y * this._mapYScale + this._mapYOffset;\r\n\t\t\tevent.data = coords;\r\n\t\t}\r\n\t\treturn event;\r\n\t}\r\n\t// for ray intersection testing\r\n\tgetIntersectionMesh() {\r\n\t\treturn this._mesh;\r\n\t}\r\n\r\n\t// a method that tells whether vr ray events should be tested against this object\r\n\tshouldTestRayEvents() {\r\n\t\treturn this._container.visible;\r\n\t}\r\n\r\n\t// abstract methods and properties\r\n\r\n\t// It should define the _map texture\r\n\tcreateMap() {\r\n\t\tthrow Error('Should be implemented in a subclass');\r\n\t}\r\n\r\n\t// This is called when a ray event is triggered over the panel\r\n\t_onPointerEvent = (e) => {\r\n\t\t// e.type: pointerdown,pointerup,pointermove,pointerupoutside\r\n\t\t// e.data: x,y in [0,1] range. e.data may be undefined\r\n\t\tthrow Error('Should be implemented in a subclass');\r\n\t};\r\n\r\n\t// public getters\r\n\tget mesh() {\r\n\t\treturn this._container;\r\n\t}\r\n}\r\n"],"names":["defaultOptions","InteractiveVRObject","targetObject","worldContainer","controllersManager","options","__publicField","THREE.Raycaster","markerGeo","THREE.SphereGeometry","THREE.Mesh","THREE.MeshBasicMaterial","CMEventTypes","event","e","allowEventPropagation","intersection","marker","s","ray","_a","VrInteractivePanel","THREE.Group","frontface","THREE.PlaneGeometry","backface","geo","THREE.BufferGeometry","BufferGeometryUtils.mergeGeometries","c1","c2","visible","canvasWidthPx","canvasHeightPx","contentHeightPx","aspect","yScale","yOffset","type","coords"],"mappings":"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"}