var c=Object.defineProperty;var f=(a,t,e)=>t in a?c(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e;var i=(a,t,e)=>f(a,typeof t!="symbol"?t+"":t,e);import{y as p,u,M as l,n as h,z as y,a as _,h as m}from"./VRButton.js";import{E as d,m as v}from"./ControllersManager.js";const R={debugLevel:1};class E{constructor(t,e,s,n){i(this,"_raycaster");i(this,"_hitTestMesh");i(this,"_lastRayStartedOnHand");i(this,"_options");i(this,"_leftHitMarker");i(this,"_rightHitMarker");i(this,"_targetObject");if(this.options={...R,...n},e===void 0||s===void 0||t===void 0)throw Error("InteractiveVRObject: Missing parameters");if(typeof t.onRayStarted!="function"||typeof t.onRayEnded!="function")throw Error("InteractiveVRObject: targetObject does not implement the required methods");if((t==null?void 0:t.getIntersectionMesh())!=null)this._hitTestMesh=t.getIntersectionMesh();else throw Error("InteractiveVRObject: targetObject does not implement the getIntersectionMesh method");if(this._targetObject=t,this._controllersManager=s,this._worldContainer=e,this._controllersManager=s,this._raycaster=new p,this.options.debugLevel>0){const r=new u(.01,16,8);this._leftHitMarker=new l(r,new h({color:16711680})),this._rightHitMarker=new l(r,new h({color:65280})),this._worldContainer.add(this._leftHitMarker),this._worldContainer.add(this._rightHitMarker)}this._setupEventListeners()}_setupEventListeners(){[{type:d.ON_RAY_STARTED,handler:"_onRayStarted"},{type:d.ON_RAY_UPDATED,handler:"_onRayUpdated"},{type:d.ON_RAY_ENDED,handler:"_onRayEnded"}].forEach(e=>{this._controllersManager.addEventListener(e.type,this[e.handler].bind(this))})}_onRayStarted(t){if(!this._targetObject.shouldTestRayEvents())return!0;let e=!0,s=this._getRayIntersection(t.ray);return s&&!this._lastRayStartedOnHand&&(this._lastRayStartedOnHand=t.handedness,e=!1,this._targetObject.onRayStarted&&this._targetObject.onRayStarted(s)),e}_onRayUpdated(t){if(!this._targetObject.shouldTestRayEvents())return!0;let e=!0,s=t.handedness=="left"?this._leftHitMarker:this._rightHitMarker,n=this._getRayIntersection(t.ray);if(n){this._lastRayStartedOnHand==t.handedness&&(e=!1,this._targetObject.onRayUpdated&&this._targetObject.onRayUpdated(n));let o=1+t.ray.origin.distanceTo(n.point)*.5;s.position.copy(n.point),s.scale.set(o,o,o),s.visible=!0}else s.visible=!1;return e}_onRayEnded(t){if(!this._targetObject.shouldTestRayEvents())return!0;let e=!0,s=t.handedness=="left"?this._leftHitMarker:this._rightHitMarker,n=this._getRayIntersection(t.ray);return this._lastRayStartedOnHand==t.handedness&&(this._targetObject.onRayEnded&&this._targetObject.onRayEnded(n),this._lastRayStartedOnHand=null,e=!1),s.visible=!1,e}_getRayIntersection(t){var e;if(this._hitTestMesh&&t){this._raycaster.ray=t;const s=(e=this._raycaster.intersectObject(this._hitTestMesh,!1))==null?void 0:e[0];if(s)return s}return null}}const b={mode:"panel",debugLevel:1,size:1};class O{constructor(t,e,s){i(this,"_container");i(this,"_mesh");i(this,"_map");i(this,"_mapYScale");i(this,"_mapYOffset");i(this,"_controllersManager");i(this,"_worldContainer");i(this,"_frontMaterial");i(this,"_backMaterial");i(this,"_onPointerEvent",t=>{throw Error("Should be implemented in a subclass")});if(this.options={...b,...s},t===void 0||e===void 0)throw Error("VrMenu: Missing parameters");this._controllersManager=e,this._worldContainer=t,this._container=new y,this._frontMaterial=new h({color:16777215}),this._backMaterial=new h({color:11184810}),this._mesh=new l(this._buildGeometry(),[this._backMaterial,this._frontMaterial]),this._container.add(this._mesh),this._interactiveVRObject=new E(this,t,e)}_buildGeometry(){const t=new _(this.options.size,this.options.size),e=new _(this.options.size,this.options.size);e.rotateY(Math.PI);let s=new m;s=v([e,t]);let n=t.index.count,r=e.index.count;return s.addGroup(0,n,0),s.addGroup(n,r,1),s}setVisible(t){this._container.visible=t}toggleVisibility(){this._container.visible=!this._container.visible,this.setVisible(this._container.visible)}_updateAspectRatio(t,e,s){const n=t/s,r=s/e,o=1-r;this._map.offset.set(0,o),this._map.repeat.set(1,r),this._mesh.scale.y=1/n,this._mapYOffset=o,this._mapYScale=r}onRayStarted(t){this._onPointerEvent(this._createPointerEvent("pointerdown",t))}onRayUpdated(t){this._onPointerEvent(this._createPointerEvent("pointermove",t))}onRayEnded(t){t?this._onPointerEvent(this._createPointerEvent("pointerup",t)):this._onPointerEvent(this._createPointerEvent("pointerupoutside"))}_createPointerEvent(t,e){let s={type:t};if(e&&e.uv){let n=e.uv.clone();n.y=n.y*this._mapYScale+this._mapYOffset,s.data=n}return s}getIntersectionMesh(){return this._mesh}shouldTestRayEvents(){return this._container.visible}createMap(){throw Error("Should be implemented in a subclass")}get mesh(){return this._container}}export{O as V};
//# sourceMappingURL=VrInteractivePanel.js.map
