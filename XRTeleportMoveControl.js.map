{"version":3,"file":"XRTeleportMoveControl.js","sources":["../node_modules/three-mesh-bvh/src/core/Constants.js","../node_modules/three-mesh-bvh/src/core/build/geometryUtils.js","../node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js","../node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","../node_modules/three-mesh-bvh/src/core/build/splitUtils.js","../node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","../node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js","../node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js","../node_modules/three-mesh-bvh/src/core/build/buildUtils.js","../node_modules/three-mesh-bvh/src/core/build/buildTree.js","../node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","../node_modules/three-mesh-bvh/src/math/MathUtilities.js","../node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","../node_modules/three-mesh-bvh/src/math/OrientedBox.js","../node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","../node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js","../node_modules/three-mesh-bvh/src/core/utils/BufferStack.js","../node_modules/three-mesh-bvh/src/core/cast/shapecast.js","../node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js","../node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","../node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","../node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js","../node_modules/three-mesh-bvh/src/core/cast/refit.generated.js","../node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js","../node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js","../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js","../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js","../node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js","../node_modules/three-mesh-bvh/src/utils/BufferUtils.js","../node_modules/three-mesh-bvh/src/core/cast/bvhcast.js","../node_modules/three-mesh-bvh/src/core/MeshBVH.js","../node_modules/three-mesh-bvh/src/objects/MeshBVHHelper.js","../node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js","../node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js","../src/utils/BoxAxesHelper.js","../src/xr/XRTeleportMoveControl.js"],"sourcesContent":["// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange( geo ) {\n\n\tconst triCount = getTriCount( geo );\n\tconst drawRange = geo.drawRange;\n\tconst start = drawRange.start / 3;\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( triCount, end ) - offset;\n\treturn [ {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t} ];\n\n}\n\nexport function getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn getFullGeometryRange( geo );\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\n\tconst drawRange = geo.drawRange;\n\tconst drawRangeStart = drawRange.start / 3;\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\tfor ( const group of geo.groups ) {\n\n\t\tconst groupStart = group.start / 3;\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t}\n\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ];\n\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\tranges.push( {\n\t\t\toffset: Math.floor( start ),\n\t\t\tcount: Math.floor( end - start ),\n\t\t} );\n\n\t}\n\n\treturn ranges;\n\n}\n\nexport function hasGroupGaps( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\treturn false;\n\n\t}\n\n\tconst vertexCount = getTriCount( geometry );\n\tconst groups = getRootIndexRanges( geometry )\n\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\tconst finalGroup = groups[ groups.length - 1 ];\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\tlet total = 0;\n\tgroups.forEach( ( { count } ) => total += count );\n\treturn vertexCount !== total;\n\n}\n","import { FLOAT32_EPSILON } from '../Constants.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in \"target\".\n// A bounding box is computed for the centroids of the triangles, as well, and placed in \"centroidTarget\".\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds( geo, target = null, offset = null, count = null ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index ? geo.index.array : null;\n\tconst triCount = getTriCount( geo );\n\tconst normalized = posAttr.normalized;\n\tlet triangleBounds;\n\tif ( target === null ) {\n\n\t\ttriangleBounds = new Float32Array( triCount * 6 * 4 );\n\t\toffset = 0;\n\t\tcount = triCount;\n\n\t} else {\n\n\t\ttriangleBounds = target;\n\t\toffset = offset || 0;\n\t\tcount = count || triCount;\n\n\t}\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = offset; tri < offset + count; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\t// we add the stride and offset here since we access the array directly\n\t\t// below for the sake of performance\n\t\tif ( ! normalized ) {\n\n\t\t\tai = ai * stride + bufferOffset;\n\t\t\tbi = bi * stride + bufferOffset;\n\t\t\tci = ci * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\tthis.boundingData = new Float32Array( 6 );\n\n\t}\n\n}\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t}\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition };\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\t\t\tlet t = indirectBuffer[ left ];\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition_indirect };\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\nimport { IS_LEAF } from '../utils/nodeBufferUtils.js';\n\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow( 2, 32 );\n\nexport function countNodes( node ) {\n\n\tif ( 'count' in node ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t}\n\n}\n\nexport function populateBuffer( byteOffset, node, buffer ) {\n\n\tfloat32Array = new Float32Array( buffer );\n\tuint32Array = new Uint32Array( buffer );\n\tuint16Array = new Uint16Array( buffer );\n\tuint8Array = new Uint8Array( buffer );\n\n\treturn _populateBuffer( byteOffset, node );\n\n}\n\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer( byteOffset, node ) {\n\n\tconst stride4Offset = byteOffset / 4;\n\tconst stride2Offset = byteOffset / 2;\n\tconst isLeaf = 'count' in node;\n\tconst boundingData = node.boundingData;\n\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t}\n\n\tif ( isLeaf ) {\n\n\t\tif ( node.buffer ) {\n\n\t\t\tconst buffer = node.buffer;\n\t\t\tuint8Array.set( new Uint8Array( buffer ), byteOffset );\n\n\t\t\tfor ( let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE ) {\n\n\t\t\t\tconst offset2 = offset / 2;\n\t\t\t\tif ( ! IS_LEAF( offset2, uint16Array ) ) {\n\n\t\t\t\t\tuint32Array[ ( offset / 4 ) + 6 ] += stride4Offset;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteOffset + buffer.byteLength;\n\n\t\t} else {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = node.left;\n\t\tconst right = node.right;\n\t\tconst splitAxis = node.splitAxis;\n\n\t\tlet nextUnusedPointer;\n\t\tnextUnusedPointer = _populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\tif ( ( nextUnusedPointer / 4 ) > MAX_POINTER ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t}\n\n\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\tnextUnusedPointer = _populateBuffer( nextUnusedPointer, right );\n\n\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\treturn nextUnusedPointer;\n\n\t}\n\n}\n","import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\n\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\n\nexport function generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\tconst useUint32 = triCount > 2 ** 16;\n\tconst byteCount = useUint32 ? 4 : 2;\n\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tindirectBuffer[ i ] = i;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nexport function buildTree( bvh, triangleBounds, offset, count, options ) {\n\n\t// epxand variables\n\tconst {\n\t\tmaxDepth,\n\t\tverbose,\n\t\tmaxLeafTris,\n\t\tstrategy,\n\t\tonProgress,\n\t\tindirect,\n\t} = options;\n\tconst indirectBuffer = bvh._indirectBuffer;\n\tconst geometry = bvh.geometry;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tconst partionFunc = indirect ? partition_indirect : partition;\n\n\t// generate intermediate variables\n\tconst totalTriangles = getTriCount( geometry );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tlet reachedMaxDepth = false;\n\n\tconst root = new MeshBVHNode();\n\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\treturn root;\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst geometry = bvh.geometry;\n\tif ( options.indirect ) {\n\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tif ( ! bvh._indirectBuffer ) {\n\n\t\tensureIndex( geometry, options );\n\n\t}\n\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\tconst triangleBounds = computeTriangleBounds( geometry );\n\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\n\tbvh._roots = geometryRanges.map( range => {\n\n\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\treturn buffer;\n\n\t} );\n\n}\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < ZERO_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\tconst tempPoint = new Vector3();\n\n\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t// find the edge that intersects the other triangle plane\n\t\tconst points = tri.points;\n\t\tlet count = 0;\n\t\tlet startPointIntersection = - 1;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst { start, end } = edge;\n\t\t\tstart.copy( points[ i ] );\n\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\tedge.delta( dir );\n\n\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\tcount = 2;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\ttempPoint.copy( start );\n\n\t\t\t}\n\n\t\t\t// ignore the end point\n\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t// the start point if necessary\n\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcount ++;\n\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = new _BufferStack();\n","import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side, near, far ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\tif ( distance < near || distance > far ) return null;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections, near, far ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst index = geo.index;\n\tif ( geo.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geo.attributes;\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, side, ray, i, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, side, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, side, ray, i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */\nexport function intersectRay( nodeIndex32, array, ray, near, far ) {\n\n\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\tconst invdirx = 1 / ray.direction.x,\n\t\tinvdiry = 1 / ray.direction.y,\n\t\tinvdirz = 1 / ray.direction.z;\n\n\tconst ox = ray.origin.x;\n\tconst oy = ray.origin.y;\n\tconst oz = ray.origin.z;\n\n\tlet minx = array[ nodeIndex32 ];\n\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\tlet miny = array[ nodeIndex32 + 1 ];\n\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\tlet minz = array[ nodeIndex32 + 2 ];\n\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\tif ( invdirx >= 0 ) {\n\n\t\ttmin = ( minx - ox ) * invdirx;\n\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t} else {\n\n\t\ttmin = ( maxx - ox ) * invdirx;\n\t\ttmax = ( minx - ox ) * invdirx;\n\n\t}\n\n\tif ( invdiry >= 0 ) {\n\n\t\ttymin = ( miny - oy ) * invdiry;\n\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t} else {\n\n\t\ttymin = ( maxy - oy ) * invdiry;\n\t\ttymax = ( miny - oy ) * invdiry;\n\n\t}\n\n\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\tif ( invdirz >= 0 ) {\n\n\t\ttzmin = ( minz - oz ) * invdirz;\n\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t} else {\n\n\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t}\n\n\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t//return point closest to the ray (positive side)\n\n\treturn tmin <= far && tmax >= near;\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, side, ray, vi, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast( bvh, root, side, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst( bvh, root, side, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t// eslint-disable-next-line no-unreachable\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast_indirect( bvh, root, side, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst_indirect( bvh, root, side, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToBufferType( array, BufferConstructor ) {\n\n\tif ( array === null ) {\n\n\t\treturn array;\n\n\t} else if ( array.buffer ) {\n\n\t\tconst buffer = array.buffer;\n\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst ArrayConstructor = array.constructor;\n\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\tresult.set( array );\n\t\treturn result;\n\n\t} else {\n\n\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst result = new BufferConstructor( array.byteLength );\n\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\treturn result;\n\n\t}\n\n}\n","import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\n\nconst _bufferStack1 = new BufferStack.constructor();\nconst _bufferStack2 = new BufferStack.constructor();\nconst _boxPool = new PrimitivePool( () => new Box3() );\nconst _leftBox1 = new Box3();\nconst _rightBox1 = new Box3();\n\nconst _leftBox2 = new Box3();\nconst _rightBox2 = new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet offset1 = 0;\n\tlet offset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\toffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ i ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\toffset1 += roots[ i ].length;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexByteOffset = 0,\n\tnode2IndexByteOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n","import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\nexport const DEFAULT_OPTIONS = {\n\tstrategy: CENTER,\n\tmaxDepth: 40,\n\tmaxLeafTris: 10,\n\tuseSharedArrayBuffer: false,\n\tsetBoundingBox: true,\n\tonProgress: null,\n\tindirect: false,\n\tverbose: true,\n};\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\t...DEFAULT_OPTIONS,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.resolveTriangleIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects, near, far );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray, near, far );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n","import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nclass MeshBVHRootHelper extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tconstructor( bvh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'MeshBVHRootHelper';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.bvh = bvh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst boundsTree = this.bvh;\n\t\tconst group = this._group;\n\t\tgeometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\t// count the number of bounds required\n\t\t\tconst targetDepth = this.depth - 1;\n\t\t\tconst displayParents = this.displayParents;\n\t\t\tlet boundsCount = 0;\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\tif ( depth >= targetDepth || isLeaf ) {\n\n\t\t\t\t\tboundsCount ++;\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\t// fill in the position buffer with the bounds corners\n\t\t\tlet posIndex = 0;\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\tconst terminate = depth >= targetDepth || isLeaf;\n\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn terminate;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\tlet indexArray;\n\t\t\tlet indices;\n\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t// x axis\n\t\t\t\t\t0, 4,\n\t\t\t\t\t1, 5,\n\t\t\t\t\t2, 6,\n\t\t\t\t\t3, 7,\n\n\t\t\t\t\t// y axis\n\t\t\t\t\t0, 2,\n\t\t\t\t\t1, 3,\n\t\t\t\t\t4, 6,\n\t\t\t\t\t5, 7,\n\n\t\t\t\t\t// z axis\n\t\t\t\t\t0, 1,\n\t\t\t\t\t2, 3,\n\t\t\t\t\t4, 5,\n\t\t\t\t\t6, 7,\n\t\t\t\t] );\n\n\t\t\t} else {\n\n\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t// X-, X+\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t} else {\n\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t}\n\n\t\t\tconst indexLength = indices.length;\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\tconst posOffset = i * 8;\n\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the geometry\n\t\t\tgeometry.setIndex(\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\n\t\t\t);\n\t\t\tgeometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\n\t\t\t);\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass MeshBVHHelper extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tconstructor( mesh = null, bvh = null, depth = 10 ) {\n\n\t\t// handle bvh, depth signature\n\t\tif ( mesh instanceof MeshBVH ) {\n\n\t\t\tdepth = bvh || 10;\n\t\t\tbvh = mesh;\n\t\t\tmesh = null;\n\n\t\t}\n\n\t\t// handle mesh, depth signature\n\t\tif ( typeof bvh === 'number' ) {\n\n\t\t\tdepth = bvh;\n\t\t\tbvh = null;\n\n\t\t}\n\n\t\tsuper();\n\n\t\tthis.name = 'MeshBVHHelper';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.bvh = bvh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst bvh = this.bvh || this.mesh.geometry.boundsTree;\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tconst root = this._roots.pop();\n\t\t\troot.geometry.dispose();\n\t\t\tthis.remove( root );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new MeshBVHRootHelper( bvh, edgeMaterial, depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.bvh = bvh;\n\t\t\troot.depth = depth;\n\t\t\troot.displayParents = displayParents;\n\t\t\troot.displayEdges = displayEdges;\n\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tconst mesh = this.mesh;\n\t\tconst parent = this.parent;\n\n\t\tif ( mesh !== null ) {\n\n\t\t\tmesh.updateWorldMatrix( true, false );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( parent.matrixWorld )\n\t\t\t\t\t.invert()\n\t\t\t\t\t.multiply( mesh.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.matrix.decompose(\n\t\t\t\tthis.position,\n\t\t\t\tthis.quaternion,\n\t\t\t\tthis.scale,\n\t\t\t);\n\n\t\t}\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\t\tthis.bvh = source.bvh;\n\t\tthis.opacity = source.opacity;\n\t\tthis.color.copy( source.color );\n\n\t}\n\n\tclone() {\n\n\t\treturn new MeshBVHHelper( this.mesh, this.bvh, this.depth );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport class MeshBVHVisualizer extends MeshBVHHelper {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconsole.warn( 'MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.' );\n\n\t}\n\n}\n\nexport { MeshBVHHelper };\n","// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\treturn hit;\n\n}\n","import { Ray, Matrix4, Mesh, Vector3 } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst ray = /* @__PURE__ */ new Ray();\nconst direction = /* @__PURE__ */ new Vector3();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\nconst _worldScale = /* @__PURE__ */ new Vector3();\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\textractMatrixScale( this.matrixWorld, _worldScale );\n\t\tdirection.copy( ray.direction ).multiply( _worldScale );\n\n\t\tconst scaleFactor = direction.length();\n\t\tconst near = raycaster.near / scaleFactor;\n\t\tconst far = raycaster.far / scaleFactor;\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material, near, far ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material, near, far );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js#L732\n// extracting the scale directly is ~3x faster than using \"decompose\"\nfunction extractMatrixScale( matrix, target ) {\n\n\tconst te = matrix.elements;\n\tconst sx = target.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\tconst sy = target.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\tconst sz = target.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\treturn target.set( sx, sy, sz );\n\n}\n","import * as THREE from 'three';\r\n\r\nimport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\r\n\r\n// color Mode 1: RGB, colorMode 2: CMY\r\nconst colorModes = [\r\n\t{\r\n\t\tx: 0xff0000,\r\n\t\ty: 0x0ff00,\r\n\t\tz: 0x0000ff,\r\n\t},\r\n\t{\r\n\t\tx: 0x00ffff,\r\n\t\ty: 0xff00ff,\r\n\t\tz: 0xffff00,\r\n\t},\r\n];\r\n\r\nexport class BoxAxesHelper extends THREE.Mesh {\r\n\tconstructor(size = 1, thickness = 0.1, colorMode = 0) {\r\n\t\t// Crea un buffer de geometrías vacío\r\n\t\tconst geometries = [];\r\n\r\n\t\t// Eje X - color rojo\r\n\t\tconst xGeometry = new THREE.BoxGeometry(size, thickness, thickness);\r\n\t\txGeometry.translate(size / 2, 0, 0); // Traslada la geometría para que parta del origen\r\n\t\tgeometries.push(xGeometry);\r\n\r\n\t\t// Eje Y - color verde\r\n\t\tconst yGeometry = new THREE.BoxGeometry(thickness, size, thickness);\r\n\t\tyGeometry.translate(0, size / 2, 0); // Traslada la geometría para que parta del origen\r\n\t\tgeometries.push(yGeometry);\r\n\r\n\t\t// Eje Z - color azul\r\n\t\tconst zGeometry = new THREE.BoxGeometry(thickness, thickness, size);\r\n\t\tzGeometry.translate(0, 0, size / 2); // Traslada la geometría para que parta del origen\r\n\t\tgeometries.push(zGeometry);\r\n\r\n\t\t// Combina las geometrías en una sola\r\n\t\tconst combinedGeometry = BufferGeometryUtils.mergeGeometries(geometries);\r\n\r\n\t\t// Materiales para cada eje\r\n\t\tconst materials = [\r\n\t\t\tnew THREE.MeshPhongMaterial({ color: colorModes[colorMode].x }), // Rojo para X\r\n\t\t\tnew THREE.MeshPhongMaterial({ color: colorModes[colorMode].y }), // Verde para Y\r\n\t\t\tnew THREE.MeshPhongMaterial({ color: colorModes[colorMode].z }), // Azul para Z\r\n\t\t];\r\n\r\n\t\t// Asigna los grupos de materiales a la geometría para que cada parte tenga su color\r\n\t\tcombinedGeometry.groups = [\r\n\t\t\t{ start: 0, count: xGeometry.index.count, materialIndex: 0 },\r\n\t\t\t{ start: xGeometry.index.count, count: yGeometry.index.count, materialIndex: 1 },\r\n\t\t\t{ start: xGeometry.index.count + yGeometry.index.count, count: zGeometry.index.count, materialIndex: 2 },\r\n\t\t];\r\n\r\n\t\t// Crea el mesh utilizando la geometría combinada y el array de materiales\r\n\t\tsuper(combinedGeometry, materials);\r\n\t}\r\n}\r\n","import * as THREE from 'three';\r\nimport { ControllersManager, EventTypes as CMEventTypes } from './ControllersManager.js';\r\nimport { computeBoundsTree, disposeBoundsTree, acceleratedRaycast, MeshBVHHelper } from 'three-mesh-bvh';\r\nimport { BoxAxesHelper } from './../utils/BoxAxesHelper';\r\n\r\nconst STICK_ARROW_THRESHOLD = 0.5; // modulus of stick position has to be larger than this value to show arrow on gizmo\r\n\r\nconst TORUS_RADIUS = 0.3;\r\nconst TORUS_TUBE = 0.02;\r\nconst ARROW_UPDATE_THRESHOLD = 1500; // msec\r\nconst TELEPORT_ARROW_ANGLE_INCREMENT = Math.PI / 12; //\r\n\r\nconst ROTATION_INCREMENT = 15; //degrees\r\nconst FORWARD_SPEED = 10; // meters/second\r\nconst VERTICALITY_THRESHOLD = 0.75;\r\n\r\nexport const defaultOptions = {\r\n\tshowHelpers: true,\r\n\tenableContinousMotion: true, // enables translation using the stick, in the direction of the ray\r\n\trestrictVerticalMovement: false,\r\n\tenabledHands: 'right', // which hands are enabled for teleporting, flying or rotating ( can beleft, right or both)\r\n};\r\n\r\nconst enabledHandsOptions = ['left', 'right', 'both'];\r\n\r\nexport class XRTeleportMoveControl {\r\n\toptions;\r\n\tcontrollersManager;\r\n\tscene;\r\n\txrManager;\r\n\r\n\traycaster;\r\n\ttestSurface;\r\n\tteleportGizmo;\r\n\tgizmoArrow;\r\n\tvrIsPresenting;\r\n\r\n\txrRigidTransform;\r\n\tbaseReferenceSpace;\r\n\r\n\treferenceSpaceHelper;\r\n\tworldSpaceHelper;\r\n\r\n\tvrCamera; // is an array camera, its coordinates are in the world space (not in the xrReferenceSpace)\r\n\r\n\tworldOffset = new THREE.Vector3(0, 0, 0);\r\n\tworldYRotation = (0 * Math.PI) / 2; // 0 means looking to the negative z axis\r\n\r\n\tuserHeight = undefined;\r\n\tuserHeightHasBeenMeasured = false;\r\n\r\n\ttestRay;\r\n\tarrowHelper;\r\n\r\n\tenabledHands = [];\r\n\r\n\t_teleportGestureIsActive = false;\r\n\t/*\r\n  \r\n  Geometry and reference spaces in WebXR\r\n  https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Geometry\r\n\r\n  */\r\n\tconstructor(xrManager, controllersManager, scene, options = {}) {\r\n\t\tthis.options = Object.assign(defaultOptions, options);\r\n\t\tthis.xrManager = xrManager;\r\n\t\tthis.controllersManager = controllersManager;\r\n\t\tthis.scene = scene;\r\n\t\tthis.raycaster = new THREE.Raycaster();\r\n\t\tthis.raycaster.firstHitOnly = true;\r\n\r\n\t\tthis.testRay = new THREE.Ray(new THREE.Vector3(0, 15, 0), new THREE.Vector3(0, -1, 0));\r\n\r\n\t\tif (this.options.showHelpers) {\r\n\t\t\tthis.referenceSpaceHelper = new BoxAxesHelper(1.5, 0.02, 0);\r\n\t\t\tlet sprite = this._createSpriteLabel('Reference Space', 1);\r\n\t\t\tsprite.position.set(0, 1, 0);\r\n\t\t\tsprite.frustumCulled = false;\r\n\t\t\tthis.referenceSpaceHelper.add(sprite);\r\n\t\t\tthis.scene.add(this.referenceSpaceHelper);\r\n\r\n\t\t\tthis.worldSpaceHelper = new BoxAxesHelper(0.75, 0.04, 1);\r\n\t\t\tsprite = this._createSpriteLabel('World Space', 1);\r\n\t\t\tsprite.frustumCulled = false;\r\n\t\t\tsprite.position.set(0, 0.5, 0);\r\n\t\t\tthis.worldSpaceHelper.add(sprite);\r\n\t\t\tthis.scene.add(this.worldSpaceHelper);\r\n\t\t}\r\n\r\n\t\tif (this.options.enabledHands == 'both') {\r\n\t\t\tthis.enabledHands = ['left', 'right'];\r\n\t\t} else {\r\n\t\t\tthis.enabledHands = [this.options.enabledHands]; // [\"left\", \"right\"] or [\"left\"] or [\"right\"]\r\n\t\t}\r\n\t\tthis._setupListeners();\r\n\t\tthis._buildGizmo();\r\n\t}\r\n\r\n\t_setupListeners() {\r\n\t\t// When the session starts\r\n\t\tthis.xrManager.addEventListener('sessionstart', (e) => {\r\n\t\t\tthis.userHeightHasBeenMeasured = false;\r\n\t\t\tthis.vrIsPresenting = true;\r\n\r\n\t\t\tthis.baseReferenceSpace = this.xrManager.getReferenceSpace();\r\n\t\t\tthis.vrCamera = this.xrManager.getCamera();\r\n\r\n\t\t\tthis._applyCurrentTransform();\r\n\t\t});\r\n\r\n\t\t// When the session ends\r\n\t\tthis.xrManager.addEventListener('sessionend', (e) => {\r\n\t\t\tthis.vrIsPresenting = false;\r\n\t\t\tthis.baseReferenceSpace = null;\r\n\t\t});\r\n\r\n\t\t// Teleportation events\r\n\r\n\t\tthis.controllersManager.addEventListener(\r\n\t\t\tCMEventTypes.ON_RAY_STARTED,\r\n\t\t\t(e) => {\r\n\t\t\t\tif (!this._teleportSurfaces || !this.enabledHands.includes(e.handedness)) return;\r\n\r\n\t\t\t\tthis.raycaster.ray = e.ray;\r\n\t\t\t\tlet intersection = this.raycaster.intersectObject(this._teleportSurfaces);\r\n\t\t\t\tif (intersection && intersection[0]?.point) {\r\n\t\t\t\t\tthis._teleportGestureIsActive = true;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t\t-999\r\n\t\t);\r\n\r\n\t\tthis.controllersManager.addEventListener(\r\n\t\t\tCMEventTypes.ON_RAY_UPDATED,\r\n\t\t\t(e) => {\r\n\t\t\t\tif (\r\n\t\t\t\t\t!this._teleportSurfaces ||\r\n\t\t\t\t\t!this.enabledHands.includes(e.handedness) ||\r\n\t\t\t\t\t!this._teleportGestureIsActive\r\n\t\t\t\t)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tthis.raycaster.ray = e.ray;\r\n\t\t\t\tlet intersection = this.raycaster.intersectObject(this._teleportSurfaces);\r\n\t\t\t\tif (\r\n\t\t\t\t\tintersection &&\r\n\t\t\t\t\tintersection[0]?.point &&\r\n\t\t\t\t\tintersection[0]?.face &&\r\n\t\t\t\t\tthis._isHorizontalSurface(intersection[0].face.normal)\r\n\t\t\t\t) {\r\n\t\t\t\t\tlet point = intersection[0].point;\r\n\t\t\t\t\tthis._updateTeleportGizmo(new THREE.Vector3(point.x, point.y, point.z), e.stickPosition, e.ray);\r\n\t\t\t\t\treturn false; // stop event propagation to other listeners\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t\t-999\r\n\t\t);\r\n\r\n\t\tthis.controllersManager.addEventListener(\r\n\t\t\tCMEventTypes.ON_RAY_ENDED,\r\n\t\t\t(e) => {\r\n\t\t\t\tif (\r\n\t\t\t\t\t!this._teleportSurfaces ||\r\n\t\t\t\t\t!this._teleportGestureIsActive ||\r\n\t\t\t\t\t!this.enabledHands.includes(e.handedness)\r\n\t\t\t\t)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tthis.raycaster.ray = e.ray;\r\n\t\t\t\tconst intersection = this.raycaster.intersectObject(this._teleportSurfaces);\r\n\t\t\t\t//console.log('intersection', intersection, this.testRay);\r\n\t\t\t\tlet stopEventPropagation;\r\n\t\t\t\tif (\r\n\t\t\t\t\tintersection &&\r\n\t\t\t\t\tintersection[0]?.point &&\r\n\t\t\t\t\tintersection[0]?.face &&\r\n\t\t\t\t\tthis._isHorizontalSurface(intersection[0].face.normal)\r\n\t\t\t\t) {\r\n\t\t\t\t\tlet point = intersection[0].point;\r\n\t\t\t\t\tthis._teleport(new THREE.Vector3(point.x, point.y, point.z), e.stickPosition, e.ray);\r\n\t\t\t\t\tstopEventPropagation = false;\r\n\t\t\t\t}\r\n\t\t\t\tstopEventPropagation = true;\r\n\t\t\t\tthis._teleportGestureIsActive = false;\r\n\t\t\t\tthis.teleportGizmo.visible = false;\r\n\t\t\t\treturn stopEventPropagation;\r\n\t\t\t},\r\n\t\t\t-999\r\n\t\t);\r\n\r\n\t\tthis._updateArrow = (ray) => {\r\n\t\t\tif (this.arrowHelper) {\r\n\t\t\t\tthis.scene.remove(this.arrowHelper);\r\n\t\t\t}\r\n\t\t\tthis.arrowHelper = new THREE.ArrowHelper(ray.direction, ray.origin, 20, 0xff9900);\r\n\t\t\tthis.scene.add(this.arrowHelper);\r\n\t\t};\r\n\r\n\t\t// Rotation events\r\n\t\tthis.controllersManager.addEventListener(\r\n\t\t\tCMEventTypes.ON_ROTATE_LEFT,\r\n\t\t\t(e) => {\r\n\t\t\t\tif (this._teleportGestureIsActive || !this.enabledHands.includes(e.handedness)) return;\r\n\t\t\t\tthis._rotate(-ROTATION_INCREMENT);\r\n\t\t\t},\r\n\t\t\t-999\r\n\t\t);\r\n\r\n\t\tthis.controllersManager.addEventListener(\r\n\t\t\tCMEventTypes.ON_ROTATE_RIGHT,\r\n\t\t\t(e) => {\r\n\t\t\t\tif (this._teleportGestureIsActive || !this.enabledHands.includes(e.handedness)) return;\r\n\t\t\t\tthis._rotate(ROTATION_INCREMENT);\r\n\t\t\t},\r\n\t\t\t-999\r\n\t\t);\r\n\r\n\t\tif (this.options.enableContinousMotion) {\r\n\t\t\t// Listen to stick events, moving in the Y axis\r\n\t\t\tthis.controllersManager.addEventListener(\r\n\t\t\t\tCMEventTypes.ON_AXIS_Y_NOT_ZERO,\r\n\t\t\t\t(e) => {\r\n\t\t\t\t\tif (this._teleportGestureIsActive || !this.enabledHands.includes(e.handedness)) return;\r\n\t\t\t\t\tthis._moveInDirection(e.ray, e.stickPosition.y, e.deltaTime);\r\n\t\t\t\t},\r\n\t\t\t\t-999\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t_isHorizontalSurface(normal) {\r\n\t\tconst normalWorld = new THREE.Vector3().copy(normal).transformDirection(this._teleportSurfaces.matrixWorld);\r\n\r\n\t\t// Verificar si la normal apunta hacia arriba\r\n\t\tconst isVertical = normalWorld.y > VERTICALITY_THRESHOLD; // Puedes ajustar el valor 0.9 según tus necesidades\r\n\t\treturn isVertical;\r\n\t}\r\n\r\n\t_getTeleportGizmoAngle(stickPos, ray) {\r\n\t\tlet projDir = ray.direction.clone();\r\n\t\tprojDir.y = 0;\r\n\t\tprojDir.normalize();\r\n\r\n\t\tlet forwardAngle = Math.atan2(projDir.z, projDir.x);\r\n\t\tlet ang = Math.atan2(stickPos.y, -stickPos.x);\r\n\r\n\t\tang = Math.round(ang / TELEPORT_ARROW_ANGLE_INCREMENT) * TELEPORT_ARROW_ANGLE_INCREMENT;\r\n\r\n\t\treturn Math.PI / 2 + ang - forwardAngle;\r\n\t}\r\n\r\n\t_createSpriteLabel(text = '', size = 1) {\r\n\t\tconst canvas = document.createElement('canvas');\r\n\t\tconst context = canvas.getContext('2d');\r\n\r\n\t\t// Set canvas size\r\n\t\tcanvas.width = 256;\r\n\t\tcanvas.height = 256;\r\n\r\n\t\t// Set text style\r\n\t\tcontext.font = '24px Arial\t';\r\n\t\tcontext.fillStyle = 'white';\r\n\t\tcontext.textAlign = 'center';\r\n\t\tcontext.textBaseline = 'middle';\r\n\r\n\t\t// Write text on canvas\r\n\t\tcontext.fillText(text, canvas.width / 2, canvas.height / 2);\r\n\r\n\t\t// Create texture from canvas\r\n\t\tconst texture = new THREE.CanvasTexture(canvas);\r\n\r\n\t\t// Create sprite using the texture\r\n\t\tconst spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthWrite: false });\r\n\t\tconst sprite = new THREE.Sprite(spriteMaterial);\r\n\t\t// When sizeAttenutation is false, the size of the sprite is indepent of the camera distance,\r\n\t\t// but is affected by the camera FOV\r\n\r\n\t\tsprite.scale.set(size, size, size);\r\n\r\n\t\treturn sprite;\r\n\t}\r\n\r\n\t_rotate(degrees) {\r\n\t\tif (!this.vrIsPresenting || !this.baseReferenceSpace) return;\r\n\r\n\t\tlet rotationDelta = (degrees * Math.PI) / 180;\r\n\r\n\t\tthis.worldYRotation += rotationDelta;\r\n\r\n\t\tlet currentSceneOffset = this.worldOffset.clone();\r\n\r\n\t\tlet vrCamPosInRefSpace = this.vrCamera.position.clone();\r\n\t\tlet m = new THREE.Matrix4().fromArray(this.xrRigidTransform.matrix);\r\n\r\n\t\tvrCamPosInRefSpace.applyMatrix4(m);\r\n\r\n\t\t// We rotate the scene around the vrCamera position in Reference Space\r\n\t\tlet m1 = new THREE.Matrix4().makeTranslation(vrCamPosInRefSpace.x, 0, vrCamPosInRefSpace.z);\r\n\t\tlet m2 = new THREE.Matrix4().makeRotationY(rotationDelta);\r\n\t\tlet m3 = new THREE.Matrix4().makeTranslation(-vrCamPosInRefSpace.x, 0, -vrCamPosInRefSpace.z);\r\n\r\n\t\tlet mRot = new THREE.Matrix4();\r\n\t\tmRot.multiply(m1);\r\n\t\tmRot.multiply(m2);\r\n\t\tmRot.multiply(m3);\r\n\r\n\t\tcurrentSceneOffset.applyMatrix4(mRot);\r\n\t\tthis.worldOffset.copy(currentSceneOffset);\r\n\r\n\t\tthis._applyCurrentTransform();\r\n\r\n\t\tthis.teleportGizmo.visible = false;\r\n\t}\r\n\r\n\t_buildGizmo() {\r\n\t\tconst gizmoMat = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x555555, shininess: 32 });\r\n\r\n\t\tconst xrayMaterial = new THREE.ShaderMaterial({\r\n\t\t\tuniforms: {\r\n\t\t\t\tcameraPosition: { value: new THREE.Vector3(1, 1, 1) },\r\n\t\t\t},\r\n\t\t\tvertexShader: `\r\n\t\t\t\t\tprecision mediump float;\r\n\r\n\t\r\n\t\t\t\t\t\r\n\t\t\t\t\tvarying vec3 vNormal;\r\n\t\t\t\t\tvarying vec3 vPosition;\r\n\r\n\t\t\t\t\tvoid main() {\r\n\t\t\t\t\t\tvNormal = normalize(normalMatrix*vec4(normal,1.0).xyz);\r\n\t\t\t\t\t\tvPosition = (modelViewMatrix*vec4(position,1.0)).xyz;\r\n\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\t\t\t\t\t}\r\n\t\t\t\t`,\r\n\t\t\tfragmentShader: `\r\n\t\t\t\t\t\r\n\t\t\t\t\tvarying vec3 vNormal;\r\n\t\t\t\t\tvarying vec3 vPosition;\r\n\r\n\t\t\t\t\tvoid main() {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tfloat xrayOpacity = 0.8 - 0.6*abs(dot( vNormal, vec3(0.0,0.0,1.0) ));\r\n\t\t\t\t\t\tgl_FragColor = vec4(0.0, 0.8, 1.0, xrayOpacity );\r\n\t\t\t\t\t\t//gl_FragColor = vec4(vNormal, 1.0 );\r\n\t\t\t\t\t}\r\n\t\t\t\t`,\r\n\t\t\ttransparent: true,\r\n\t\t\tside: THREE.DoubleSide,\r\n\t\t\tdepthWrite: false,\r\n\t\t});\r\n\r\n\t\t// this.gizmoArrow\r\n\t\tconst arrowGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 3);\r\n\t\tarrowGeo.rotateY(Math.PI / 2);\r\n\t\tarrowGeo.translate(0.65, -0.025, 0);\r\n\r\n\t\tthis.gizmoArrow = new THREE.Mesh(arrowGeo, xrayMaterial);\r\n\t\tthis.gizmoArrow.visible = false;\r\n\r\n\t\t// Torus\r\n\t\tconst torusGeo = new THREE.TorusGeometry(TORUS_RADIUS, TORUS_TUBE, 16, 100);\r\n\t\ttorusGeo.rotateX(Math.PI / 2);\r\n\r\n\t\tthis.teleportGizmo = new THREE.Mesh(torusGeo, xrayMaterial);\r\n\t\tthis.teleportGizmo.add(this.gizmoArrow);\r\n\r\n\t\tthis.scene.add(this.teleportGizmo);\r\n\t\tthis.teleportGizmo.visible = false;\r\n\t}\r\n\r\n\t_updateTeleportGizmo(pos, stickPosition, ray) {\r\n\t\tthis.teleportGizmo.visible = true;\r\n\t\tthis.teleportGizmo.position.set(pos.x, pos.y + TORUS_TUBE / 2, pos.z);\r\n\r\n\t\tif (stickPosition.length() > STICK_ARROW_THRESHOLD) {\r\n\t\t\tthis.gizmoArrow.visible = true;\r\n\t\t\tthis.gizmoArrow.rotation.y = this._getTeleportGizmoAngle(stickPosition, ray);\r\n\t\t\tthis.gizmoArrow.userData.lastUpdate = Date.now();\r\n\t\t} else {\r\n\t\t\tthis.gizmoArrow.visible = false;\r\n\t\t}\r\n\t}\r\n\r\n\t_measureUserHeight() {\r\n\t\tif (this.userHeightHasBeenMeasured || !this.vrIsPresenting) return;\r\n\r\n\t\tlet pos = this.vrCamera.position.clone();\r\n\t\t// position has not been set yet from XR headser\r\n\t\tif (pos.length() === 0) return;\r\n\r\n\t\tlet m = new THREE.Matrix4().fromArray(this.xrRigidTransform.matrix);\r\n\t\tpos.applyMatrix4(m);\r\n\r\n\t\tthis.userHeight = pos.y;\r\n\t\tthis.userHeightHasBeenMeasured = true;\r\n\t}\r\n\r\n\t_teleport(destinationPos, stickPosition, ray) {\r\n\t\t/*\r\n\t\tdestinationPos: the position where the user wants to teleport in world space origin, not to the xrReferenceSpace\r\n\t\t\r\n\t\tTeleport references:  \r\n\t\thttps://threejs.org/examples/webxr_vr_teleport.html\r\n\t\thttps://github.com/smarthug/teleport\r\n\t\thttps://discourse.threejs.org/t/teleport-functionality-in-webxrmanager-webxrcontroller/18605/2\r\n\t\thttps://medium.com/@darktears/adding-support-for-vr-inputs-with-webxr-and-three-js-235b40beb6f0\r\n  \r\n\r\n    */\r\n\t\tif (!this.vrIsPresenting || !this.baseReferenceSpace) return;\r\n\r\n\t\tconst arrowUpdateElpasedTime = this.gizmoArrow.userData.lastUpdate\r\n\t\t\t? Date.now() - this.gizmoArrow.userData.lastUpdate\r\n\t\t\t: Infinity;\r\n\r\n\t\tif (stickPosition && ray && arrowUpdateElpasedTime < ARROW_UPDATE_THRESHOLD) {\r\n\t\t\t// get head direction vector in world space\r\n\t\t\tlet headDir = this.vrCamera.getWorldDirection(new THREE.Vector3(0, 0, -1));\r\n\t\t\theadDir.y = 0;\r\n\t\t\theadDir.normalize();\r\n\t\t\tlet headAngle = Math.atan2(headDir.z, headDir.x);\r\n\r\n\t\t\t/*\r\n\t\t\t// get the direction of ray in the XZ plane\r\n\t\t\tlet rayDir = ray.direction.clone();\r\n\t\t\trayDir.y = 0;\r\n\t\t\trayDir.normalize();\r\n\t\t\tlet rayAngle = Math.atan2(rayDir.z, rayDir.x);\r\n\t\t\t*/\r\n\t\t\t// get the angle of the ray in the XZ plane\r\n\r\n\t\t\t// get the angle of the arrow in the XZ plane\r\n\t\t\tlet arrowAngle = this.gizmoArrow.rotation.y;\r\n\r\n\t\t\t// arrowAngle is 0 in +x and 90 in +z\r\n\t\t\t// rayAngle,headAngle are 0 in +x and 90 in -z\r\n\t\t\t// that's why they are added instead of subtracted\r\n\r\n\t\t\tlet deltaRotation = -(arrowAngle + headAngle);\r\n\t\t\tthis.worldYRotation += deltaRotation;\r\n\t\t}\r\n\r\n\t\tthis.gizmoArrow.visible = false;\r\n\r\n\t\tlet targetPos = destinationPos.clone().negate();\r\n\r\n\t\tlet mRot = new THREE.Matrix4().makeRotationY(this.worldYRotation);\r\n\t\ttargetPos.applyMatrix4(mRot);\r\n\r\n\t\t//this.vrCamera.position() is the position in xrReferenceSpace\r\n\t\t//apply offset between the vrCamera and the xrReferenceSpace\r\n\r\n\t\tlet vrCamPosInWorldSpace = this.vrCamera.position.clone();\r\n\t\tlet m = new THREE.Matrix4().fromArray(this.xrRigidTransform.matrix);\r\n\t\tvrCamPosInWorldSpace.applyMatrix4(m);\r\n\r\n\t\ttargetPos.x += vrCamPosInWorldSpace.x;\r\n\t\ttargetPos.z += vrCamPosInWorldSpace.z;\r\n\r\n\t\tthis.worldOffset.set(targetPos.x, targetPos.y, targetPos.z);\r\n\r\n\t\tthis._applyCurrentTransform();\r\n\t\tthis.teleportGizmo.visible = false;\r\n\t}\r\n\r\n\t// this method is called when the user moves the stick in the Y axis\r\n\t_moveInDirection(ray, stickPositionY, deltaTime) {\r\n\t\t// deltaTime is in seconds\r\n\t\tlet rayDir = ray.direction.clone();\r\n\t\trayDir.normalize();\r\n\r\n\t\tif (this.options.restrictVerticalMovement) {\r\n\t\t\trayDir.y = 0;\r\n\t\t\trayDir.normalize();\r\n\t\t}\r\n\r\n\t\trayDir.multiplyScalar(stickPositionY * FORWARD_SPEED * deltaTime);\r\n\r\n\t\tlet mRot = new THREE.Matrix4().makeRotationY(this.worldYRotation);\r\n\t\trayDir.applyMatrix4(mRot);\r\n\r\n\t\tthis.worldOffset.add(rayDir);\r\n\r\n\t\t//this._applyCurrentTransform();\r\n\t}\r\n\r\n\t_applyCurrentTransform() {\r\n\t\tif (!this.baseReferenceSpace) return;\r\n\r\n\t\tlet offsetPosition = this.worldOffset.clone();\r\n\r\n\t\t// calculation: offsetPosition = [yRotation] * this.worldOffset\r\n\t\t//const mRot = new THREE.Matrix4().makeRotationY(this.worldYRotation);\r\n\t\t//offsetPosition.applyMatrix4(mRot);\r\n\r\n\t\t// execute transform\r\n\t\tlet offsetRotation = new THREE.Quaternion();\r\n\t\toffsetRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.worldYRotation);\r\n\r\n\t\tthis.xrRigidTransform = new XRRigidTransform(\r\n\t\t\tnew THREE.Vector3(offsetPosition.x, offsetPosition.y, offsetPosition.z),\r\n\t\t\toffsetRotation\r\n\t\t);\r\n\r\n\t\tconst spaceOffset = this.baseReferenceSpace.getOffsetReferenceSpace(this.xrRigidTransform);\r\n\r\n\t\tthis.xrManager.setReferenceSpace(spaceOffset);\r\n\r\n\t\t// xrRigidTransform es la transformacion de WorldSpace(Scene) respecto de ReferenceSpace\r\n\t\tlet mat = new THREE.Matrix4().fromArray(this.xrRigidTransform.matrix);\r\n\t\t// la inversa me da la transformacion de ReferenceSpace respecto de WorldSpace (Scene)\r\n\t\tmat.invert();\r\n\r\n\t\tlet pos = new THREE.Vector3();\r\n\t\tpos.applyMatrix4(mat);\r\n\r\n\t\tif (this.options.showHelpers) {\r\n\t\t\tthis.referenceSpaceHelper.position.copy(pos);\r\n\t\t\tthis.referenceSpaceHelper.rotation.setFromRotationMatrix(mat);\r\n\t\t}\r\n\t}\r\n\r\n\t// xrRigidTransform es la transformacion de WorldSpace(Scene) respecto de ReferenceSpace\r\n\tgetXRRigidTransform() {\r\n\t\treturn new THREE.Matrix4().fromArray(this.xrRigidTransform.matrix);\r\n\t}\r\n\r\n\tupdate(deltaTime) {\r\n\t\tif (this.vrIsPresenting) {\r\n\t\t\tthis._applyCurrentTransform();\r\n\t\t\t//this._measureUserHeight();\r\n\t\t}\r\n\t}\r\n\r\n\tsetTeleportSurfaces(geometry) {\r\n\t\t// BVHMesh  https://github.com/gkjohnson/three-mesh-bvh\r\n\t\tgeometry.computeBoundsTree = computeBoundsTree.bind(geometry);\r\n\t\tgeometry.disposeBoundsTree = disposeBoundsTree.bind(geometry);\r\n\t\tgeometry.computeBoundsTree();\r\n\r\n\t\tthis._teleportSurfaces = new THREE.Mesh(\r\n\t\t\tgeometry,\r\n\t\t\tnew THREE.MeshBasicMaterial({\r\n\t\t\t\tside: THREE.DoubleSide,\r\n\t\t\t})\r\n\t\t);\r\n\t\tthis._teleportSurfaces.raycast = acceleratedRaycast.bind(this._teleportSurfaces);\r\n\t\tthis._teleportSurfaces.updateMatrixWorld();\r\n\r\n\t\tif (this.options.showHelpers) {\r\n\t\t\tlet bvhHelper = new MeshBVHHelper(this._teleportSurfaces, 0xff0000);\r\n\t\t\tbvhHelper.displayEdges = true;\r\n\t\t\tthis.scene.add(bvhHelper);\r\n\t\t}\r\n\t}\r\n\r\n\t_testRayCaster() {\r\n\t\tthis.testRay.origin.set(0, 20, 0);\r\n\t\tthis.testRay.direction.set(0, -1, 0);\r\n\t\tthis.raycaster.ray = this.testRay;\r\n\t\tthis._updateArrow(this.testRay);\r\n\t\tconst intersection = this.raycaster.intersectObject(this._teleportSurfaces);\r\n\t\tconsole.log('intersection', intersection);\r\n\t}\r\n}\r\n"],"names":["CENTER","AVERAGE","SAH","CONTAINED","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","BYTES_PER_NODE","IS_LEAFNODE_FLAG","FLOAT32_EPSILON","SKIP_GENERATION","getVertexCount","geo","getTriCount","getIndexArray","vertexCount","BufferConstructor","ensureIndex","options","index","BufferAttribute","i","getFullGeometryRange","triCount","drawRange","start","end","offset","count","getRootIndexRanges","ranges","rangeBoundaries","drawRangeStart","drawRangeEnd","group","groupStart","groupEnd","sortedBoundaries","a","b","hasGroupGaps","geometry","groups","finalGroup","total","getBounds","triangleBounds","target","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","computeTriangleBounds","posAttr","normalized","posArr","bufferOffset","stride","getters","tri","tri3","tri6","ai","bi","ci","el","c","min","max","halfExtents","el2","arrayToBox","nodeIndex32","array","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","dist","copyBounds","source","unionBounds","aVal","bVal","d","d3","expandByTriangleBounds","startIndex","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","BIN_COUNT","binsSort","sahBins","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","axis","pos","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","binWidth","truncatedBins","bin","leftCacheBounds","rightCacheBounds","splitCount","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","nextBin","binCount","avg","MeshBVHNode","partition","indirectBuffer","split","left","right","axisOffset","t0","tb","partition_indirect","t","IS_LEAF","n16","uint16Array","OFFSET","n32","uint32Array","COUNT","LEFT_NODE","RIGHT_NODE","SPLIT_AXIS","float32Array","uint8Array","MAX_POINTER","countNodes","node","populateBuffer","byteOffset","buffer","_populateBuffer","stride4Offset","stride2Offset","isLeaf","boundingData","l","offset2","splitAxis","nextUnusedPointer","generateIndirectBuffer","useSharedArrayBuffer","useUint32","byteCount","buildTree","bvh","maxDepth","verbose","maxLeafTris","onProgress","indirect","indexArray","partionFunc","totalTriangles","cacheCentroidBoundingData","reachedMaxDepth","root","splitNode","triggerProgress","trianglesProcessed","depth","splitOffset","lstart","lcount","rstart","rcount","buildPackedTree","geometryRanges","range","nodeCount","SeparatingAxisBounds","points","field","val","p","other","Vector3","box","boxMin","boxMax","x","y","z","closestPointLineToLine","dir1","dir2","v02","l1","l2","result","v0","v10","v2","v32","d0232","d3210","d3232","d0210","denom","closestPointsSegmentToSegment","paramResult","Vector2","temp1","temp2","target1","target2","p2","closestPoint","closestPoint2","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","triangle","radius","plane","pp","ZERO_EPSILON","isNearZero","value","ExtendedTriangle","Triangle","args","Sphere","satAxes","satBounds","axis0","sab0","axis1","sab1","axis2","sab2","axis3","sab3","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","dir","tempDir","edge1","edge2","tempPoint","triIntersectPlane","targetEdge","startPointIntersection","startIntersects","doesIntersect","suppressLog","plane1","plane2","satBounds1","satAxes1","sb","sa","satBounds2","satAxes2","sa1","i2","sa2","count1","count2","tmp","s1","e1","s2","e2","separated1","separated2","point","cornerFields","line1","line2","lineTarget","otherVec","thisVec","f11","f12","f21","f22","OrientedBox","matrix","Matrix4","v","minVec","pi","alignedSatBounds","aabbBounds","saTri","pointsArr","triSatBounds","triSatAxes","xyzFields","segments1","segments2","threshold","threshold2","i1","nextIndex","nextIndex2","index2","p1","f1","f2","f3","PrimitivePool","getNewPrimitive","primitives","primitive","ExtendedTrianglePoolBase","ExtendedTrianglePool","_BufferStack","stack","prevBuffer","BufferStack","_box1","_box2","boxStack","boxPool","Box3","shapecast","intersectsBounds","intersectsRange","boundsTraverseOrder","shapecastTraverse","length","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","nodeIndex16","getLeftOffset","getRightEndOffset","c1","c2","score1","score2","box1","box2","temp","isC1Leaf","c1Intersection","c1StopTraversal","isC2Leaf","c2Intersection","c2StopTraversal","closestPointToPoint","minThreshold","maxThreshold","minThresholdSq","maxThresholdSq","closestDistanceTriIndex","score","triIndex","closestDistance","_vA","_vB","_vC","_uvA","_uvB","_uvC","_normalA","_normalB","_normalC","_intersectionPoint","checkIntersection","ray","pA","pB","pC","side","near","far","intersect","BackSide","DoubleSide","distance","checkBufferGeometryIntersection","position","normal","uv","uv1","intersection","face","intersectTri","intersections","triOffset","setTriangle","ta","tc","i0","intersectTris","_indirectBuffer","intersectClosestTri","res","iterateOverTriangles","intersectsTriangleFunc","contained","refit","nodeIndices","indexArr","roots","_traverse","node32Index","force","node16Index","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","intersectRay","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","ox","oy","oz","intersectTris_indirect","vi","intersectClosestTri_indirect","iterateOverTriangles_indirect","raycast","intersects","_raycast","leftIndex","rightIndex","_xyzFields","raycastFirst","_raycastFirst","xyzAxis","leftToRight","c1Result","c2Result","boundingBox","triangle2","invertedMat","obb","obb2","intersectsGeometry","otherGeometry","geometryToBvh","_intersectsGeometry","cachedObb","thisGeometry","thisIndex","thisPos","tempMatrix","temp3","temp4","closestPointToGeometry","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistanceOtherTriIndex","otherOffset","otherCount","refit_indirect","j","raycast_indirect","raycastFirst_indirect","intersectsGeometry_indirect","ti","closestPointToGeometry_indirect","otherBvh","ti2","isSharedArrayBufferSupported","_bufferStack1","_bufferStack2","_boxPool","_leftBox1","_rightBox1","_leftBox2","_rightBox2","_active","bvhcast","matrixToLocal","intersectsRanges","otherRoots","offset1","invMat","il","localBox","jl","node1Index32","node2Index32","matrix2to1","matrix1to2","intersectsRangesFunc","node1IndexByteOffset","node2IndexByteOffset","depth1","depth2","currBox","reversed","bufferStack1","bufferStack2","float32Array1","uint32Array1","uint16Array1","float32Array2","uint32Array2","uint16Array2","node1Index16","node2Index16","isLeaf1","isLeaf2","newBox","cl1","cr1","intersectCl1","intersectCr1","cl2","cr2","leftIntersects","rightIntersects","tempBox","DEFAULT_OPTIONS","MeshBVH","rootData","indexAttribute","data","newIndex","callback","rootIndex","materialOrSide","FrontSide","isMaterial","isArrayMaterial","raycastFunc","materialSide","startCount","materialIndex","closestResult","raycastFirstFunc","geomToMesh","intersectsGeometryFunc","callbacks","iterateFunc","intersectsTriangle","originalIntersectsRange","nodeIndex","intersectsTriangles","triangle1","indexAttr1","positionAttr1","assignTriangle1","indexAttr2","positionAttr2","assignTriangle2","iterateOverDoubleTriangles","index1","originalIntersectsRanges","boxToMesh","MeshBVHRootHelper","Object3D","material","BufferGeometry","boundsTree","targetDepth","displayParents","boundsCount","posIndex","positionArray","terminate","xVal","yVal","zVal","indices","indexLength","posOffset","indexOffset","MeshBVHHelper","Group","mesh","edgeMaterial","LineBasicMaterial","meshMaterial","MeshBasicMaterial","totalRoots","displayEdges","parent","children","convertRaycastIntersect","hit","object","raycaster","Ray","direction","tmpInverseMatrix","origMeshRaycastFunc","Mesh","_worldScale","acceleratedRaycast","extractMatrixScale","scaleFactor","hits","computeBoundsTree","disposeBoundsTree","te","sx","sy","sz","colorModes","BoxAxesHelper","THREE.Mesh","size","thickness","colorMode","geometries","xGeometry","THREE.BoxGeometry","yGeometry","zGeometry","combinedGeometry","BufferGeometryUtils.mergeGeometries","materials","THREE.MeshPhongMaterial","STICK_ARROW_THRESHOLD","TORUS_RADIUS","TORUS_TUBE","ARROW_UPDATE_THRESHOLD","TELEPORT_ARROW_ANGLE_INCREMENT","ROTATION_INCREMENT","FORWARD_SPEED","VERTICALITY_THRESHOLD","defaultOptions","XRTeleportMoveControl","xrManager","controllersManager","scene","__publicField","THREE.Vector3","THREE.Raycaster","THREE.Ray","sprite","e","CMEventTypes","_a","_b","stopEventPropagation","THREE.ArrowHelper","stickPos","projDir","forwardAngle","ang","text","canvas","context","texture","THREE.CanvasTexture","spriteMaterial","THREE.SpriteMaterial","THREE.Sprite","degrees","rotationDelta","currentSceneOffset","vrCamPosInRefSpace","m","THREE.Matrix4","m1","m2","m3","mRot","xrayMaterial","THREE.ShaderMaterial","THREE.DoubleSide","arrowGeo","THREE.CylinderGeometry","torusGeo","THREE.TorusGeometry","stickPosition","destinationPos","arrowUpdateElpasedTime","headDir","headAngle","deltaRotation","targetPos","vrCamPosInWorldSpace","stickPositionY","deltaTime","rayDir","offsetPosition","offsetRotation","THREE.Quaternion","spaceOffset","mat","THREE.MeshBasicMaterial","bvhHelper"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]}